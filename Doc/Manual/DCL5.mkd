Руководство по написанию скриптов на языке DCL5
===============================================

*Версия 10.1.29.301*

 

DCL5 - что это такое?
---------------------

DCL5 -- представляет скриптовый, интерпретируемый язык, для создания интерфейса
приложения использующего какую-либо СУБД. Он описывает, что должен содержать
диалог, какие действия будут производиться при нажатии описанных кнопок.

При написании приложений на этом языке Вам не надо заботиться о размещении и
компоновке визуальных элементов форм, это за Вас сделает сам DCL5.

Основная часть бизнес-логики, должна быть реализована средствами самой СУБД и её
хранимыми процедурами, триггерами и т.д.

Концепция DCL5, в том, что используя ограниченный набор специальных визуальных
компонент, создать полноценное бизнес-приложение, притом, эти компоненты
являются макро-компонентами, включающими несколько сложных действий, порою,
скрытых от разработчика, дабы не отягчать его излишней черновой работой, из
которых подобно блокам складывается интерфейс приложения.

Кроме интерфейсной части, язык содержит в себе средства манипуляции данных и
организации простой бизнес-логики.

Код, который оперирует визуальными компонентами, отделён от кода манипуляции
данных и бизнес-логики, хотя это не строгое разделение.

 

Структура построения предложения на языке DCL5
----------------------------------------------

Предложение в DCL5 строится по принципу идущих друг за другом директив,
представляющих собой пары *ИмяДирективы=Значение*, они могут быть подчинены друг
другу и таким образом вложены, когда одна директива заменяется значением, а та в
свою очередь принимает это значение как дополнение или основное своё значение,
или же просто быть в виде списка пар директив, разделённых между собой знаком
разделения директив «;». Строго говоря, директивы всегда разделяются знаком
разделения директив, если она не вложены. В качестве значений директив, могут
выступать фиксированные значения, как упоминалось ранее, так и значения
подставляемые запросами, из которых чаще всего берут одну строку, переменными,
функциями, параметрами или объектами полей. Все специальные значения, такие как
функции, переменные, параметры, объекты полей, всегда указываются через
предшествующий префикс, в языке DCL5, нет спонтанных значений. Все предложения в
DCL5 записываются в одну строку, какими длинными они бы не были. Исключения
составляют, секции, в них могут помещаться многострочные значения.

 

Понятие множеств в DCL5
-----------------------

Множествами в языке DCL5 являются строчные значения, передаваемые в функции или
обрабатываемые с помощью соответствующих функций, разделённых символом запятая
«,», значения содержащие запятые, но не подлежащие трактовке как отдельные
элементы, экранируются символов кавычек (") и терминированные, но не
обязательно, символом дочка с запятой «;».

Такие множества обрабатываются, например, функциями *IndexOf()* или *Count()*.
Сами параметры функций, строго говоря, тоже являются множествами, и если там, в
одном из параметров встретилась запятая, то такой параметр нужно экранировать
символом ". Таким образом, можно передать список значений в компонент Список
выбора, и по индексу выбранного элемента забрать значение из множества обратно,
например, для печать.

 

Командные и визуальные скрипты
------------------------------

В DCL5 существуют несколько видов скриптов, одни создают диалоги и описывают их
поведение, другие предназначены для исполнения команд при нажатии на кнопки или
при наступлении некоторых событий. Есть так же скрипты позволяющие выполнить
команды операционной системы или скриптов на языке VBScript.

Для построения диалогов и исполнения событий визуальной среды, существуют
визуальные и командные скрипты. Командные скрипты, используются для кнопок и
некоторых действий с БД, визуальные, для построения диалогов отображения данных.
И они могут быть вызваны с помощью меню или директивы `Dialog=`.

Для явного определения типа скрипта используется директива

`Script Type=`

определяющая тип скрипта. Если Скрипт командный, тогда после равно ставится
слово

Command

если же это визуальный скрипт, то *Visual* или директива просто не ставится.

Если в описании команды напротив него стоит надпись (V, C) то эту команду можно
использовать во всех типах скриптов, то же значит и её отсутствие. (C)
обозначает что команда может работать только в командных скриптах, (V) только в
визуальных.

Визуальные скрипты, являются также, формами, в них возможно создание визуальных
компонент, в них поддерживается ограниченный набор команд, а упор сделан на
визуальную часть. Они могут исполнятся только линейно, однонаправлено вперёд.
Командные скрипты, напротив, поддерживают ограниченный набор визуальных команд,
основным в них является исполнение команд манипуляции данных или логических
выражений и могут использовать переходы по условиям и возврат к прежней точке
исполнения.

Командные скрипты, вызываются с тем же
[контекстом](../HYPERLINK#Терминологический_словарь) что и вызвавший их скрипт,
это даёт возможность командам обращаться к формам, визуальным компонентам или
основному НД.

Скрипты для исполнения команд операционной системы должны начинаться с директивы
`Script Type=ShellCommand`. И содержать только команды DOS/Windows или
bash/Linux. Однако в них допустимо использовать переменные и параметры.

Скрипты содержащие макросы *VBScript (только для Windows)*, должны начинаться с
директивы `Script Type=VBScript`*.* Могут содержать операторы на языке
*VBScript*, процедуры и функции и их вызов. Здесь так же возможно использование
параметров и переменных.

 

Запросы
-------

Запросы в визуальных скриптах, создают НД, который в дальнейшем, может быть
отображён с помощью визуальных компонентов.

`Query=`

Запрос для основной таблицы. Не допускается указания запросов, не возвращающих
данных, таких как *insert into, delete from, update, create index* и т.д..

Допускается указание двух предложений *Query*, первый будет использоваться для
сброса фильтрации и поиска, а второй для открытия таблицы. В этом предложении
невозможно интерпретация параметров, но допускается указание переменных.

 
**Параметры :**

`Sleeping=`

Если равно 1, то откладывает открытие запроса до команды *Open;*.

`FromFile=`

Если запрос очень длинный, то его можно разместить в файле, указав его имя в
этой директиве. Очень не рекомендуется это делать, такое действие проделывает
серьёзную брешь в безопасности системы.

`UserRaights=`

SQL выражение для ограничения прав доступа к конкретному запросу. В нём
указывается условие выборки по полю UID из таблице пользователей.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UserRaights=in (select UID from &_DCL_USERS_TABLE_ where ACCESSLEVEL>3);
[QUERY]
текст SQL
[END QUERY]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Аналогично предложению *Query=*. Секция может содержать многострочный запрос.

`DefaultQuery=` (V)

Используется для возвращения НД в исходное состояние после фильтрации и поиска,
если не указан, то используется первое по счету, с верху предложение `Query=`.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DefaultQuery= select * from Calls order by CallDate;
Query= select first 20 * from Calls order by CallDate;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Таким образом, можно при открытии диалога не показывать всю таблицу, тем более
что если она большая, а показать первые 20 записей.

`FindQuery=` (V)

Указывает запрос, использующийся только для поиска.

`Open;` (V)

Открывает запрос, объявленный с параметром `Slepping=1`.


**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Query= select first 20 * from Calls order by CallDate;Slepping=1;
...
...
Open;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


`ExecQuery=` (С)

Позволяет выполнить любой запрос к любой таблице.
 

**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ExecQuery=insert into Parts(Name,PartIndex) Values("Independent Part","647744");
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В данном примере производится добавление в таблицу Parts новой записи.

`GlobQuery=` (C)

Выполняет запрос непосредственно на просматриваемой базе данных, может
использоваться, например, для восстановления запроса или смены отображаемого НД.


**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If 0=&ClientsViewMode then
GlobQuery=select * from clients where c.del=1 order by c.name;
SetValue=ClientsViewMode=1;
Else
GlobQuery=select * from clients where c.del is null order by c.name;
SetValue=ClientsViewMode=0;
EndIf;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


`TablePartQuery=` (C)

Устанавливает текст запроса в табличной части, текст должен удовлетворять
условиям, описанным в разделе [Табличные части](../HYPERLINK#Табличные_части).

 
**Параметры :**

`TablePartNum=`

Устанавливает номер табличной части, счет ведётся с единицы.


**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TablePartQuery=select * from Phones where Client_ID=:CID;TablePartNum=1;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`UpdateQuery=` (ADO, IB, BDE, ZEOS) (V)

Предложение, включающее в себя директивы определения запросов для удаления,
редактирования, вставки, а так же ключей для однозначного определения записи.


**Директивы** (IB, BDE, ZEOS) :

`ModifySQL=`

Запрос использующийся в процессе изменения.

`InserSQL=`

Запрос использующийся в процессе вставки новой записи.

`DeleteSQL=`

Запрос использующийся в процессе удаления.

 

**Вместо директив ModifySQL, InserSQL, DeleteSQL можно использовать:**

`UpdateTable=`

Указывается одна таблица, которая будет изменяться.

`UpdateFields=`

Список полей, через запятую, для изменения.

`KeyFields=`

Список ключевых полей, через запятую.

Использовать не запросы, а директиву `UpdateTable=`, более просто и быстро, а
использование запросов, позволяет сделать изменение таблиц более гибким. Без
этой директивы, изменяемой будет считаться первая таблица в запросе.

 

>   **Примечание :**

>   Для сервера Firebird и InterBase запросы строятся автоматически, без
>   использования каких либо параметров, из SQL запроса берётся первая по счёту
>   таблица и из неё берутся поля для построения запросов, если только структура
>   таблиц построена правильно и указаны первичные ключи.

 

>   Используйте директиву *UpdateTable=*, так же и для ADO, в этом случае
>   директива *KeyFields=* игнорируется. Однако, желательно завершать
>   предложение в целях унификации конфигураций для разных типов механизма
>   доступа к данным.

 

**Форматы запросов должны быть следующими :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Modifysql=update ТАБЛИЦА set Поле1=:Поле1, Поле2=:Поле2, ПолеN=:ПолеN where Поле_с_уникальным_значением=OLD_ Поле_с_уникальным_значением;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Insertsql=insert into ТАБЛИЦА(Поле1, Поле2, ПолеN) values (:Поле1, :Поле2, :ПолеN);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Deletesql=delete from ТАБЛИЦА where Поле_с_уникальным_значением=OLD_ Поле_с_уникальным_значением;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

>   **Примечание** (BDE) :

>   Недопустимо использования директив *CashBase=0* и *Live=1* вместе с
>   предложением *UpdateQuery=*.

>   Назначение запросов и возможность редактирования, зависит от кнопок
>   навигатора.

 

`UniqueTable=` (ADO)(V)

Определяет основную таблицу набора данных, над которой будут осуществляться
действия. Указание параметра обязательно в запросах из более чем, одной таблицы.
Параметр указывается после открытия НД. Аналогично предложению *UpdateQuery=* с
директивой *UpdateTable=*, устанавливает таблицу для изменения. Желательно, в
целях унификации, использовать именно предложение *UpdateQuery=*, со всеми его
директивами.

 

`UpdateResync=` (ADO)(V)

Показывать только что добавленные и изменённые записи, только после обновления
НД.

 

`AutoApply=` (V)

Не использовать кнопки управления пакетным сохранением (Убирает кнопки
*«Сохранить»*, *«Отменить»*.), сохранять изменения сразу. По умолчанию опция
включена.


`ReOpen;`

Переоткрывает текущую таблицу. Рекомендуется использовать после предложений:

*ModifyingQuery, ExecQuery*.
 

`ReСonnect;`

Реинициализация текущего соединения с БД.

 

Параметры запросов
------------------

В DCL5 существуют параметры запросов, они используются для изъятия какого либо
значения из основного набора данных. Обращение к ним производится через знак «:»
и имя поля просматриваемой таблицы, вместо него интерпретатор DCL5 подставит из
нее значение.

>   **Примечание :**

>   Параметры являются безтиповыми, при их использовании следите за типами
>   данных с которыми они применяются.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SetValue=vCallDate=:CALL_DATE;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В результате выполнения этой строки, в переменную vCallDate занесётся значение
поля CALL_DATE.

 

**Режим блокировки** (ADO)(V)
-----------------------------

`LockType=`

**Определяет тип блокировки. Задаётся следующими параметрами:**

-   *Optimistic* -- (по умолчанию) не мешает редактировать записи другим
    пользователям.

-   *Pessimistic* -- осуществляет монопольную блокировку записей.

-   *ReadOnly* -- только для чтения.

 

**Тип курсора** (ADO)(V)
------------------------

`CursorType=`

**Определяет тип курсора. Поддерживаются следующие значения:**

-   Keyset

-   Dynamic

-   Static

 

**Ограничение редактирования данных**
-------------------------------------

Директива :

`DataReadOnly=`

Принимает значения «1» - включено. Таким образом делая набор данных не
редактируемым. Аналогично команде `AddNotAllowOperation=` с добавлением всех
опций.

 

**Режимы открытия таблиц (BDE) (V)**
------------------------------------

Директива :

`CashBase=`

Указывает как сохранять изменения в БД, если равно 1 то изменения сохраняются во
временном файле и в конце работы могут быть сохранены в базе или отменены, если
0 то происходит непосредственное сохранение в БД.

`Live=` (BDE)(V)

Задает режим отправки исполнения запросов, при равном 1 запросы будут
рассматриваться локальным приложением, при 0 непосредственно отправляться на
сервер, параметр так же влияет на возможность непосредственного редактирования
таблицы, если 1 то можно править, а если 0 то изменить базу можно только
запросами или используя предложение *UpdateQuery*.

 

>   **Примечание :**

>   (BDE) Значение директивы *Live=0* и отсутствие его вообще означает не одно и
>   тоже, при отсутствии директивы *Live* подразумевается как *Live=1*.

>    

>   (BDE) При включенном *Live*, т.е. равным «1» поиск и контекстная фильтрация
>   будут регистрозависимыми.

 

`ParamCheck=`

Отключает если равно 0, внутреннюю интерпретацию параметров или включает (по
умолчанию) если равно 1.

 

Поля сортировки
===============

Существуют запросы, в которых невозможно упорядочивать результат по некоторым
полям, и нужно ограничить набор полей для сортировки для этого служит
предложение:

`OrderByFields=` (V)

где через запятую указываются поля для сортировки по текущему запросу.

 

Диалоги
-------

Вызов диалогов
--------------

Осуществляется с помощью предложения

`Dialog=` (C)

где, параметром служит имя визуального скрипта. Диалог может быть вызван только
из командного скрипта.

 

**Параметры :**

`ExternalQuery=`

Позволяет указать SQL запрос, который послужит основным для открываемого
диалога. В тексте запроса допустимо использование переменных и параметров.

`Child=`

Указывает на то, что вызываемый диалог, будет дочерним для вызывающего и
унаследует его контекст, даже если вызов произведён через командный скрипт.
Принимает значения «1» - Да, «0» - Нет.

`TablePart=`

Передаёт НД из указанной табличной части. Указывается её номер или 0 если
текущей. Является взаимоисключающей директивой для директивы *Child=.*

`ModalOpen=`

Модальное открытие диалога, исполнение скрипта при этом, приостанавливается.
Принимает значения «1» - Да, «0» - Нет.

`ChooseMode=`

Режим выбора значения из диалога, принимает следующие значения: 0 --- нет, 1 ---
Выбрать, 2 --- Выбрать и закрыть. Для осуществления занесения значений в
соответствующие места и поля необходимо заполнить некоторые параметры, см. ниже.

`KeyField=`

Ключевое поле выбираемого НД. Используется для режима выбора.

`DataField=`

Поле, содержащие данные, выбираемого НД.

`ModifyField=`

Изменяемое поле НД, вызвавшего диалог выбора.

`EditName=`

Имя поля ввода, для занесения в него данных из поля объявленного в параметре
`DataField=`. Если параметр не пуст то, ключевое значение занесётся в поле в
параметре `ModifyField=`, а данные в поле ввода.

 

События диалогов
----------------

Для реализации событий на некоторые действия в DCL5 существуют конструкции
определяющие события.

`Events=` (V)

Предложение определяющее события, включает в себя директивы определения на какое
именно действие предполагается определить событие. Предложение *Events*
указывается только в визуальных скриптах.

### События :

#### События набора данных.

`CloseEvents=`

Определяет события на закрытие формы диалога, через запятую указываются имена
командных скриптов, предназначенные для выполнения.

`PostBeforeEvents=`

Определяет события до сохранение данных в БД, через запятую указываются имена
командных скриптов, предназначенные для выполнения.

`PostAfterEvents=`

Определяет события после сохранение данных в БД, через запятую указываются имена
командных скриптов, предназначенные для выполнения.

`CancelEvents=`

Определяет события на отмену сохраненных данных в БД, через запятую указываются
имена командных скриптов, предназначенные для выполнения.

`BeforeScrollEvents=`

Определяет события до перемещения по записям в БД, через запятую указываются
имена командных скриптов, предназначенные для выполнения.

`ScrollEvents=`

Определяет события на перемещение по записям в БД, через запятую указываются
имена командных скриптов, предназначенные для выполнения.

`InsertEvents=`

Определяет события до вставки новой записи в БД, через запятую указываются имена
командных скриптов, предназначенные для выполнения.

`DeleteEvents=`

Определяет события после удаления записи в БД, через запятую указываются имена
командных скриптов, предназначенные для выполнения.

`BeforeCommitEvents=`

События до сохранения.

`AfterCommitEvents=`

События после сохранения.

`BeforeRollBackEvents=`

События до отката изменений.

`AfterRollBackEvents=`

События после отката изменений.

`AfterOpenEvents=`

События после открытия НД.

 

#### События табличных частей.

`InsertPartEvents=`

Определяет события до вставки новой записи в НД табличной части, допустимо
указать один скрипт, предназначенный для выполнения.

`ScrollPartEvents=`

Определяет события прокрутки НД табличной части, допустимо указать один скрипт,
предназначенный для выполнения.

`PostPartEvents=`

Определяет события сохранения НД табличной части, допустимо указать один скрипт,
предназначенный для выполнения.

 

#### События визуальных компонент.

`LineDblClickEvents=`

События двойного щелчка по строке таблицы. Через запятую указываются командные
скрипты.


Режим одного экземпляра диалога
-------------------------------

Для предотвращения открытия второго экземпляра диалога, в скрипте диалога ставиться директива 

`Single;`



Режим запрещения закрытия диалога
---------------------------------

Запретить закрытие диалога, до выполнения определённых действий, можно с помощью
директивы:

`NoCloseable=` (C, V)

Она принимает значения 1 или 0, при значении 1, диалог закрыть невозможно, но
можно зарыть программу. При значении 0, закрытие диалога становится возможно.

`CloseQuery=` (V)

Показывает вопрос при закрытии диалога. В значении указывается текст вопроса, 
если он не будет указан, то будет выводится "Закрыть диалог?".


 

Обращение к диалогам по имени
-----------------------------

Для явного задания диалога и обращение к нему по имени используется предложение:

`DialogByName=` (С)

Это требуется тогда когда командный скрипт, выполняется в контексте другой
формы, а обратиться нужно не к ней.

После имени диалога, через точку, указывается действие над ним.

 
**Параметры :**

`DialogByName=Имя_Диалога.Действие;`

**Где, действия :**

-   *Hide* -- скрыть.

-   *Show* -- показать.

-   *Close* -- закрыть.

-   *ReFresh* -- обновить НД.

 

Обращение к полям ввода по имени
--------------------------------

Для произведения действий над явным полем ввода используется предложение

`EditByName=` (С)

После имени поля ввода, через точку, указывается действие над ним. В качестве
полей ввода могут выступать следующие поля ввода: EditBox, InputBox, OutBox. Для
этого при их описании должна быть использована директива ComponentName явно
задающее имя компонента ввода.
 

**Параметры :**

`EditByName=Имя_Поля_Ввода.Действие;`

**Где, действия :**

-   *Hide* -- скрыть.

-   *Show* -- показать.

-   *SetFocus* -- передать фокус ввода.

-   *Clear* -- очистить.

-   *Enable* -- Сделать доступным.

-   *Disable* -- Сделать не доступным.

-   *Select* -- Выделить текст.

-   *SetText* -- Установить текст. Текст помещается в директиве \_Value=.
 

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
EditByName=ClientPhoneBox.SetText;_Value=&Phone;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Здесь в поле ввода с именем ClientPhoneBox помещается значение переменной Phone.

 

Интерфейс
=========

Меню
----

Язык DCL5 позволяет создавать меню и назначать события на него.

Пункты меню, объявляются непосредственно в базе скриптов, в виде записей,
надпись заносится в поле определенное параметром *DCLNameField* в файле
настройки модуля, уровень меню определяется в поле заданным параметром
*IdentifyField*, туда заносятся уникальные идентификаторы пунктов, определяющие
их уровень, для пунктов меню верхнего уровня используются идентификаторы от 1 до
1000 включительно, для пунктов второго уровня начиная от 1001 до 10000
включительно, для меню третьего уровня, используются идентификаторы от 10001 до
16000, таким образом можно создать трёхуровневое меню. Для пунктов ниже первого
уровня дополнительно нужно указать родителя в поле определенным параметром
*ParentFlgField*, указывается идентификатор пункта меню верхнего уровня.

Командный скрипт, может задаваться непосредственно в поле для текста скрипта
(поле *DCLTextField*) в виде текста или в поле имени скрипта (поле
*CommandField*) определяя имя запускаемого скрипта. Второй способ является
предпочтительным, так как дает большую гибкость.

Идентификатор с номером 0 используется для окна меню, надпись в поле
определяемым параметром *DCLNameField*, будет являться его заголовком.

 

Статус панели
-------------

Идентификаторы, начиная с 20001 до 20050 включительно предназначены для создания
панелей подсказок (статуса) на главной форме. В поле *ParentFlgField* может
указывать ширину панели в пикселях. В поле *DCLNameField* задается надпись на
панели, или в поле *DCLTextField* задается запрос, возвращающий текст.

Для создания статус панелей на диалогах используются следующие команды :

`Status=`

Помещает в панель статуса текст. Допускается использование переменных и
параметров. В директиве *Status* указывается номер панели. Вместо номера можно
указать слово *Last*, означающее последнюю панель.

`AddStatus=`

Добавляет статус панель с надписью указанной после равно. И шириной указанной в
директиве *Width=*.

`DeleteStatus=`

Удаляет статус панель с номером указанным после равно. Счет ведется с 1. Вместо
номера можно указать слово *Last*, означающее последнюю панель. Можно
использовать математические выражения.

`DeleteAllStatus;`

Удаляет все статус панели.

`SetStatusText=`

Устанавливает текст и ширину статус панели. Сразу после равно указывается текст,
а следующие параметры задают номер и ширину панели.

**Параметры :**

`Status=`

Указывает номер панели. Можно использовать математические выражения.

`Width=`

Задает ширину в пикселях экрана.

`StatusWidth=`

Задаёт ширину статус панели, с номером указанным после равно.

**Параметры :**

`Width=`

Задает ширину в пикселях экрана.

`RebuildMainStatusPanel;` (C)

Используется для обновления данных в статус панелях.

 

Сообщения и диалог выбора
-------------------------

`Message=` (V, C)

Показывает окно с сообщением, работа программы при этом приостанавливается.
Допускается использование переменных и параметров.

**Параметры** (C) :

`Flags=`

Указывает тип окна сообщения. Поддерживается только в командных скриптах.

**Значения параметра :**

-   *YesNo* -- будет появляться диалог выбора да или нет.

-   *Input* -- Стандартное окно ввода.

`DefaultValue=`

Исходное значение для окна ввода значения. Допускается использование параметров
и переменных. Поддерживается только в командных скриптах.

`VariableName=`

Обязательный параметр, указывает переменную для помещения результата выбора.
Если было выбрано «Да», тогда в переменную занесётся «1», и «0» если ответ был
«Нет». Если же используется флаг *Input*, тогда в переменную заносится введенное
значение. Поддерживается только в командных скриптах.
 

>   **Примечание :**

>   Режим выбора и режим ввода значения, работают только из командного скрипта.

 

Строки для добавления к заголовку
---------------------------------

Идентификаторы начиная с 20051 до 20100 включительно предназначены для задания
текста прибавляемого к заголовку окна.

 

Окна
----

`Caption=Заголовок окна`

Устанавливает заголовок окна. Допускается использовать переменные.

`Style=`

Управляет стилем отображения информации на форме.

Если равно 0 то поля будут выводиться в виде формы с расположением элементов
строго друг под другом

Поле1

Поле2

Поле3

Если равно 1 то поля будут выводиться в виде формы с расположением элементов в
виде лесенки

Поле1

Поле2

Поле3

Если равно 2 то информация будет выводиться в таблице.

`Orientation=`

Директива, управляющая, порядком полей на форме, если она имеет значение
*Horizontal*, поля выстраиваются горизонтально, слева-направо.

`Modal=` (V)

Режим окна. Если *Modal* равно 1 то окно будет поверх остальных окон.

`AllButtons;` (BDE, IB)(V)

Используется если по каким либо причинам нужно на наборе данных открытом с
директивой *Live=1* поставить все кнопки навигатора. Не указывается ни каких
параметров.

`NoVisual;` (V)

Убирает все визуальные компоненты кроме кнопок.

`NoKeys;` (V)

Не создает стандартные кнопки, такие как «Закрыть», «Сохранить», «Отменить».

`Navigator=`

Скрывает или делает видимым (по умолчанию) навигатор БД. Доступен из командного
скрипта. Притом, наличие или отсутствие кнопок делает доступными или не
доступными соответствующие операции главного НД. Таким образом можно запретить
добавление или удаление записей, любыми способами.

Для скрытия или показа кнопок навигатора используется предложение `Buttons=`:

**Параметры :**

`Buttons=`

Определяет видимые кнопки навигатора.

Допустимы следующие значения:

`First`

`Prior`

`Next`

`Last`

`Insert`

`Delete`

`Edit`

`Post`

`Cancel`

`Refresh`

Параметры указываются через запятую.

`Flat=`

Если равно 1 тогда кнопки навигатора плоские.

`ExitNoSave=` (V)

Определяет будут ли сохранятся изменения в БД или будет задаваться вопрос.
Принимает значения 1 или 0. По умолчанию равно 0.

`MultiSelect=`

Разрешает или запрещает множественный выбор в таблице. Принимает значения 1 и 0.

`ReadOnly=`

Запрещает или разрешает редактирование данных в таблице. Принимает значения 1 и
0.

`FieldsList=имя_файла`

Помещает в файл список полей просматриваемой таблицы.

`FormHeight=`

Устанавливает высоту формы в пикселях. Можно использовать математические
выражения.

`FormWidth=`

Устанавливает ширину формы в пикселях. Можно использовать математические
выражения.

 

Закладки
--------

Для работы с закладками нужно указать поле, по которому будет однозначно
определена запись, это могут быть поля с автоподстановкой значений, посредством,
например, последовательностей. Это поле должно так же явно или не явно
выводиться в запросе, построения НД.

#### `QueryKeyField=`

Для отображения заголовка закладки, нужно указать параметр :

`TitleField=`

в котором следует указать имя поля для отображения заголовка.

![](Bookmark.png)

Для удаления закладки, нужно щёлкнуть по ней с нажатой клавишей Ctrl.

 

Страницы
--------

Для создания нескольких таблиц на одной форме существуют *Страничные закладки*.
Для их создания необходимо, перед запросом, создающим НД помещается секция
*[Page]*. Далее все запросы и директивы относящиеся к созданному НД, будут
действовать только на этот НД, до следующего объявления секции *[Page]*. Так же,
командные кнопки будут создаваться на текущей странице.

`Title=`

Определяет заголовок закладки. Предложение используется после секции *[Page]* и
указывает заголовок той страницы, внутри которой оно находится.

`Orientation=`

Определяет ориентацию закладок страниц. Предложение используется один раз после
секции *[Page]*.

Допустимы следующие значения.

-   *Top* -- Классическое расположение (по умолчанию), закладки вверху.

-   *Left* -- Закладки слева, вертикально.

-   *Bottom* -- Внизу.

-   *Right* -- Закладки справа, вертикально.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Page]
Title=Клиенты;
Orientation=Left;
Query=select * from Clients;
[Page]
Title=Заказы;
Query=select * from Orders;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Выделение цветом
----------------

Для удобочитаемости таблиц, данные в них можно разгруппировать по цветам, для
этого служит предложение *Color=*. Оно содержит набор значений и цвета для
раскраски. Набор значений должен иметь следующий формат:

[Знак]ЗНАЧЕНИЕ1=Цвет1,[Знак]ЗНАЧЕНИЕ2=Цвет2

, группы должны разделяться запятой. Если не указан знак, то подразумевается
знак равно. Допустимо в качестве ЗНАЧЕНИЯ и ЦВЕТА использовать переменные.

**Знаки :**

\>, \<, \<\>, =, \>=, \<= -- Допустимые знаки.

Знак в случае равно не ставится.


**Параметры :**

`BrushKey=`

Поле в соответствии со значениями которого будет производиться раскраска.

**Цвета :**

Цвета пишутся обычными словами например, *clRed, clGreen*..., с префиксом
**cl**, или числами как десятичными так и шестнадцатеричными с ведущей буквой
**h** в начале шестнадцатеричных значений.

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Color=<2400=clRed;BrushKey=CoastSum;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Color=<>0=h45DD0C;BrushKey=CoastSum;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В данном примере будет производится раскраска тех записей, значение которых в
поле CoastSum, меньше 2400, в красный цвет.

 
Фильтрация
==========

Фильтры
-------

Для возможности фильтрации НД используется предложение `DBFilter=`. Оно содержит
ряд параметров обязательных для заполнения, они указывают например, откуда брать
данные для фильтрации или для значений фильтра. Для возврата НД в прежнее
состояние (не отфильтровано) производится выбором ключевого значения равным
"-1", для этого в таблице значений фильтра нужно добавить запись.

**Параметры :**

`SQL=`

Создает НД, который будет использоваться как набор значений для фильтрации.

`List=`

Указывает то поле, значения которого будут видны в списке для фильтрации.

`Key=`

Указывает поле со значениями фильтра.

`FilterField=`

Указывает поле в фильтруемом НД, по которому будет осуществляться фильтрация.

>   **Примечание :**

>   Параметр может отсутствовать, если указана переменная в параметре `VariableName=`.

>   Тогда запрос не будет изменяться, а при выборе значений из фильтра, переменная будет заполняться ключевыми значениями.


`Label=`

Надпись.

`VariableName=`

Имя переменной, в которую при каждом выборе фильтра, будет заносится значение
ключевого поля.

`Width=`

Задает ширину компонента.

`KeyValue=`

Позволяет установить начальное значение фильтра, для этого параметром
указывается значение ключевого поля. Возможно указание как переменных так и
запроса, первый столбец которого будет присвоен параметру.

`Between=номер_фильтра_1, номер_фильтра_2`

Позволяет задавать диапазон фильтрации между двумя значениями выбранными
фильтрами. Для этого оба фильтра должны быть полностью идентичны по полям
фильтрации. Первый фильтр в паре будет иметь приоритет по сравнению со вторым, и
при выборе только его, будет происходить обычная фильтрация, без парного
значения, фильтрация по диапазону будет происходить только при совместном выборе
фильтров пары. Допускается указывать список пар вида 1,2,5,6, где фильтрация
будет осуществляться между 1 и 2, 5 и 6 фильтрами.

Так же допустимо, и предпочтительно, указание относительного смещения номера
фильтра, например, -1,0. или -5,-4,-1,0.


>   **Примечание :**

>   Значений в предложении *Between* может быть только кратно двум.

>   Предложение *Between* ставится только после фильтров.

 
**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DBFilter=List=DateOD;Key=DateOD;FilterField=DateOD;Label=Дата нач.; DBFilterQuery=select * from "DatesOD.DB";
DBFilter=List=DateOD;Key=DateOD;FilterField=DateOD;Label=Дата конца; DBFilterQuery=select * from "DatesOD.DB";
Between=1,2
DBFilter=List=State;Key=Num;FilterField=State;Label=Статус;DBFilterQuery=select * from "State.DB";
DBFilter=List=AccType;Key=TypeNum;FilterField=TypeAcc;Label=Тип счета;DBFilterQuery=select * from "AccTypeBook.DB";
Between=3,4;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Контекстные фильтры
-------------------

Для поиска произвольного значения может быть использован контекстный фильтр. Он
аналогичен обычному фильтру, только позволяет не выбирать значения из списка, а
вводить их с клавиатуры. Для его объявления служит предложение :

`ContextFilter=` (V)


**Параметры :**

`FilterField=`

Указывает поле, по которому будет осуществляться фильтрация в НД. Если поле не
указанно и режим отображения *Style=2* (сетка), то берется текущее поле, на
котором стоит курсор.

>   **Примечание :**

>   Параметр может отсутствовать, если указана переменная в параметре `VariableName=`.

>   Тогда запрос не будет изменяться, а изменении фильтра, образец для поиска будет помещён в переменную.


`Label=`

Надпись над фильтром.

`FilterMode=`

 
**Директивы :**

-   *Case* -- Будет вестись регистрочувствительный поиск.

-   *NotLike* -- Точный поиск.

-   *Partial* -- Поиск похожих.

Допустимо объединение режимов фильтрации.

`VariableName=`

Имя переменной в которую при каждом изменении фильтра, будет заносится значение
ключевого поля.

`_Value=`

Начальное значение. Допускается использовать переменные.

`Width=`

Задает ширину компонента.

`MaxLength=`

Задает максимальную длину вводимого текста.

`WaitForEnter=`

Если параметр равен *1*, то ожидает нажатия клавиши Enter для применения
фильтрации.

`ComponentName=`

Задает имя компонента для дальнейшего обращения к нему по

имени. Если же имя не будет заданно то оно формируется по следующему принципу:
ContextFilter_N, где N номер фильтра по порядку.
 

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ContextFilter=FilterField=LASTNAME;Label=Фамилия;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*В данном примере создается фильтр по полю LASTNAME.*


>   **Примечание :**

>   Контекстные фильтры так же возможно объединять в группы для задания способа
>   фильтрации, аналогично обычным фильтрам.

`ContextBetween=`

Позволяет задавать диапазон фильтрации между двумя значениями, выбранными
фильтрами. Допускается указывать список пар вида 1,2,5,6, где фильтрация будет
осуществляться между 1 и 2, 5 и 6 фильтрами.

 

Операции над фильтрами
----------------------

`SetContextFilterText=` (C)

Задает текст в поле ввода фильтра. После равно записывается текст. Если после
равно ни чего не указать, то указанный фильтр очиститься.


**Параметры :**

`ComponentName=`

Имя компонента используемое для доступа к нему.

`ComponentNumber=`

Номер компонента, сверху вниз или с лева направо, для доступа к нему.

 
>   **Примечание :**

>   Директива *ComponentName=* является более приоритетной.
 

`ClearAllContextFilters;` (C)

Очищает все контекстные фильтры на форме.

 

Элемент управления «Календарь»
------------------------------

Используется для передачи даты в запрос посредством переменной. Для этого в
предложении *Query* должна стоять переменная и ей должно быть присвоено
значение, посредством предложения *Calendar* до выполнения запроса, для этого,
«Календарь» должен быть объявлен до запроса.

Календарь располагается на панели с фильтрами. Для создания календаря
используется следующее предложение :

`Calendar=` (V)
 

**Параметры :**

`Label=`

Задает надпись над элементом.

`VariableName=`

Имя переменной куда будет помещаться значение, если не заданно то будет

формироваться автоматически по правилу, *Calendar_\<DialogName\>+\<Номер
компонента\>*. Заранее объявлять переменную не требуется.

`DefaultValue=`

Определяет исходное значение, возможно использование переменных, если

значение опущено, то ставится текущая дата.

`ReOpen=`

Значение *1* параметра указывает на то, что необходимо переоткрыть запрос при

выборе даты.

 
**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Calendar=Label=Дата;VariableName=CDE;ReOpen=1;
Query=select * from call_stat s where s.DateCall='&CDB';
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 

>   **Примечание :**

>   Ещё раз заметьте, как написана переменная в запросе, так как она является
>   безтиповой, то с целью соблюдении типов в запросе она взята в кавычки.

 

Таблица итогов
==============

Таблицей итогов называется строка под основной таблицей и отображающая
результаты выполнения агрегатных функций над основным набором данных. Например,
можно вывести сумму и количество всех документов, содержащихся в таблице, причём
итог будет зависимым от условий поиска.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SummQuery=Count(*) CountDocs, Sum(d.doc_sum) SumDocs;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Данное предложение выведет итоговую таблицу с количеством и суммой по указанным
полям.

![](SumTable.png)
 

**Параметры :**

`Columns=`

Указываются колонки для принудительного задания им ширины. Колонки пишутся
парами Имя/Размер, разделённых запятыми. Для этого они должны быть поименованы в
предложении. При этом порядок следования колонок в таблице перестраивается как в
списке.
 

**Например :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Columns=CountDocs/80, SumDocs/120;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Табличные части
===============

Наподобие таблиц просмотра, служат для просмотра подчиненных данных.Для их
создания используется предложение:

`TablePart=`


**Параметры :**

`SQL=`

Является обязательным параметром и содержит запрос, строящий таблицу, в запросе
допускается использовать переменные. Запрос для таблицы должен соответствовать
быть построен по следующим правилам.

В качестве значения для отбора должен стоять параметр, знак двоеточия и имя поля
содержащее значение отбора :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
select * from orders where CustNo=:CustNo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

где :CustNo имя поля в главной таблице.

`DependField=`

Поле в табличной части, содержащее значение для связи с главным НД.

`UniqueTable=` (ADO)

Определяет основную таблицу набора данных табличной части, над которой будут
осуществляться действия. Указание параметра обязательно в запросах из более чем,
одной таблицы.

`Live=` (BDE)

Если равно *1*, то позволяет редактировать НД табличной части.

`MasterDataField=`

Поле в основном НД с его ключом.

`VariableName=`

Переменная со значением связующего поля из главного НД. Используется совместно с 'NoDataField='.

`NoDataField=`

Отсоединяет таблицу от мастер-НД. Принимает значение '1', в этом случае.


`Columns=`

Позволяет именовать столбцы таблицы произвольно, задавая список полей в виде:

ИмяПоля1[=Длина]/Подпись Поля 1, ИмяПоля2/Подпись Поля 2, ИмяПоля3/Подпись Поля
3.

`Navigator=`

Если параметр имеет значение *0*, то навигатор не показывается.

`NavigatorButtons=`

Определяет набор кнопок навигатора. Аналогичен параметру *Buttons=* предложения
*Navigotor*.

`Title=`

Определяет заголовок страницы.

`Style=`

Аналогично такой же директиве в основном диалоге, задаёт способ отображения.

`ReadOnly=`

Если равно *1*, то запрещает редактирование таблицы.

Сделать активной в данный момент конкретную табличную часть можно с помощью
команды :

`CurrentTablePart=` (V, C)

Она сделает активной ту табличную часть, номер которой будет указан после равно,
если требуется сделать активной последнюю ТЧ, то просто ставиться *-1*. Счёт
ведётся с 1. Команда действует для текущей странице в визуальном скрипте и для
текущей открытой в командном.


 

Кнопки табличных частей
-----------------------

Создаются на странице табличной части. Описание следующее за объявлением текущей
табличной части создаст в ней кнопки.

`TablePartToolButton=`

**Параметры :**

`Label=`

Надпись в виде всплывающей подсказки.

`Action=`

Стандартное действие. Для действий над НД активной табличной части

используются те же команды что и для основного НД только к ним в конец
прибавляется слово «_part». Не используется совместно с директивой
`CommandName=`*.*

`CommandName=`

Имя скрипта для запуска. Исключает директиву `Action=`.

`AccessLevel=`

Уровень прав для отображения кнопки, указывается число или символьное
представление, [соответствующее](#Права) уровню прав пользователя. Учитывается
уровень права, действующего в пределах текущего диалога. Допустимо указывать
переменные и функции.

 

Авто обновление набора данных
=============================

Часто бывает, что необходимо поддерживать актуальность просматриваемых данных в
открытом диалоге. Это можно решить, например с помощью периодического
принудительного обновления просматриваемого НД, но лучше это делать
автоматически. Для этого предусмотрены нижеследующие команды, текущая позиция
при этом, не теряется. Если НД находиться в режиме редактирования, то обновления
не происходит.

`AutoRefresh;`

Производит периодическое обновление просматриваемого НД через каждые 90 секунд.

`AutoRefresh=`

Производит периодическое обновление просматриваемого НД через заданное
количество секунд. Можно использовать переменные. Если значение равно нулю,
обновления не происходит.

 

Поля
====

Поля - это то что используется для отображения данных. Поля являются прямой
проекцией полей, в которые отображается набор данных с помощью
компонентов-полей. Они представляют собой набор различных компонентов, с
различными свойствами и поведением. Однако, поля также могут быть не связаны ни
с каким НД.

Описание полей начинаются с секции "*[Fields]*".

Если нужно просто отобразить все поля с заголовком каким же, как и имя поля в
базе тогда после *[Fields]* ставится "\*" (звездочка). Если же каждое поле
должно быть подписано не так как оно именуется в базе то используется следующая
конструкция :

`[Fields]`

Количество полей, которое объявляется в списке (Обязательно). Если «\*», то
ненужно и последующая секция должна отсутствовать.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Заголовок поля;Hint=Подсказка для поля;
Имя_поля_в_базе
Заголовок поля;ReadOnly=1;
Имя_поля_в_базе
Заголовок поля;Width=Ширина поля;
Имя_поля_в_базе
Пример :
[Fields]
3
Наименование;ReadOnly=1;
Name
Серийный номер;Width=50;
SN
Цена;Hint=Цена без НДС;
CoastSum
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


>   **Примечание :**

>   Запрещается использовать в именах полей и в их заголовках следующие символы

>   «\\», «;», «,» .

>   Если после символа «\\» поставить секцию *[FieldParagraphDown];* то позиция
>   поля сдвинется вниз на один элемент и образуется пустое место.

>   Если имя поля начинается со служебного слова, то такое поле должно быть
>   отодвинуто от края посредством пробела.


**Параметры :**

`ReadOnly=`

Для определения поля, как только для просмотра, к нему добавляется директива
*ReadOnly=1*.

`Width=`

Если нужно что бы длинна поля была отлична от той что ставится по умолчанию для
каждого типа поля своя, тогда после подписи поля через знак «;» ставится
директива *Width=* содержащая длину поля в пикселях.

`Height=`

Параметр действителен только для компонентов *Memo* и *Graphic*. Задаёт высоту
поля в пикселях.

`CharCase=`

Определяет регистр к которому будут преобразовываться вводимые символы.

Принимает следующие значения :

-   *LowerCase* -- все символы в нижнем регистре.

-   *UpperCase* -- все символы в верхнем регистре.

Для маскировки отображения ввода паролей используется директива `HidePassword;`

При нажатии на нём левой кнопкой мыши с зажатым Ctrl, происходит показ
содержимого, при повторном нажатии, содержимое опять скрывается.

**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Fields]
3
Роль;ReadOnly=1;
RoleName
Пароль;Width=100;HidePassword;
RolePass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 

>   **Примечание :**

>   Все директивы полей указываются после подписи поля. Через знак «;».

>   Влияние перечисленных директив распространяется по возможности, на все типы
>   полей и на все компоненты отображения данных и поля ввода.

 

### Типы данных

Для явного указания того, как отображать поле с данными служат директивы :


**Директивы :**

*As_Graphic;* -- отобразит поле как содержащее графические данные.

*As_Date;* -– установит тип поля в тип Дата.

*As_Memo;* -- отобразит поле как содержащее большой объем текста.

*As_RichText;* -- отобразит поле как содержащее форматированный текст.

*As_Logic;* -- отображает поле как содержащее данные типа *Boolean*. По
умолчанию в базу будут передаваться значения *True* и *False*. Для явного
указания, какие значения будут передаваться при взведённом и снятом
переключателе служат директивы *ValueChecked=* и *ValueUnChecked=*.

 
**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Проведен\As_Logic;ValueChecked=1;ValueUnChecked=0;
Status
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Директивы указываются через знак «\\» после надписи поля.
 

>   **Примечание :**

>   В конце директив обязательно должен присутствовать символ «;» (точка с
>   запятой).


Загрузка полей из таблицы
-------------------------

Этот режим позволяет гибко управлять построением диалогов, меняя расположение и
атрибуты полей, а так же менять их набор с помощью стандартных диалогов
непосредственно в самой программе. Для загрузки полей из таблицы служит
предложение *LoadFromTable* где единственным параметром является SQL запрос
строящий НД для представления полей. НД для представления полей должен иметь
следующую структуру:

Первое по счету поле должно содержать Заголовок поля, затем, следует поле с
именем поля. Все атрибуты полей можно вынести в отдельное поле, но оно
обязательно должно быть единым с первым по счету полем.


>   **Примечание :**

>   Не следует забывать, что по правилам SQL объединение значений с *null* в
>   итоге дает *null*. Поэтому заполняйте поля с пустыми атрибутами, пробелами.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LoadFromTable=SQL=select Field_Caption || Field_Attr, Field from FIELDSATTR;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Контекстная кнопка полей
------------------------

Для совершения каких-либо действий, рядом с полем можно поместить контекстную
кнопку, она может помещаться рядом с любым полем или компонентом поля.

`ContextButton=`


**Параметры :**

`CommandName=`

Скрипт исполняемых действий.

`Hint=`

Всплывающая подсказка.

 

Компоненты полей
================

Для ввода произвольных значений, для последующего присвоения их переменным или
выполнения запроса с их участием, для построения диалогов без НД, используются
компоненты полей. Они представляют из себя различные компоненты, позволяющие
отображать данные в различном виде. Поля-компоненты объявляются в области полей,
путем написания после надписи поля типа компонента через знак «/» после названия
поля.

 

Поля ввода
----------

Для ввода произвольных значений, для последующего присвоения их переменным или
выполнения запроса с их участием, для построения диалогов без НД, используются
поля ввода. Для их объявления служат следующие предложения :

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Fields]
2
Документов\OutBox=SQL=select Count(t1.OUTSUM) from DOCS t1, DatesOD t2 where t1.DateOD=t2.DateOD and t2.CurrentFlag=1;Disabled=1
OUTSUM1
Сумма\OutBox=SQL=select SUM(t1.OUTSUM) from DOCS t1, DatesOD t2 where t1.DateOD=t2.DateOD and t2.CurrentFlag=1;Disabled=1
OUTSUM
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

**Типы полей ввода :**

`OutBox=`

Поле отображения информации, разрешается делать только программное присвоение
значения. Ввод не поддерживается.

`InputBox=`

Поле предназначено только для ввода значения. Присвоение значения, не
поддерживается.

`EditBox=`

Поле позволяющее и отображать и редактировать значения.

`DateBox=`

Поле для ввода/вывода дат.

 

**Параметры :**

`ComponentName=`

Определяет имя компонента для последующего обращения к нему по имени, например в
предложениях `GetValue= ModifyingEdit=`. Если имя не будет заданно то она
формируется следующим образом: ТипПоляВвода\_ СвязанноеСНимПоле.

`Disabled=`

Делает поле ввода недоступным. Используется только в *OutBox*.

`ReadOnly=`

Используется для полей ввода дат, запрещает, если равно *1* ввод значений и
служит только для просмотра.

`Format=`

Указывает формат ввода. Поддерживаются следующие форматы:

*Float* -- формат ввода дробных чисел для SQL.

`_Value=`

Присваивает заранее заданное значение или значение переменной.

`_ValueIfEmpty=`

Задействуется как `_Value=`, в случае если значение пришедшее из `_Value=`, пустое.

`_ValueIfNull=`

Присваивает заранее заданное значение или значение переменной, если поле имеет значение null.

`_ValueIfNotNull=`

Присваивает заранее заданное значение или значение переменной, если поле не null.

`SQL=`

Присваивает результат работы SQL запроса состоящего из одного столбца.
Допускается использование параметров и переменных.

`ReturnField=`

Определяет возвращаемое поле заданного SQL запроса, если ни чего не заданно, то
берется первое по счету поле.

`Width=`

Задает ширину компонента. Можно использовать математические выражения.

`Hint=`

Определяет всплывающую подсказку при наведении курсора мыши на поле.

`HidePassword;`

Маскировка, для ввода/отображения паролей. При нажатии на нём левой кнопкой мыши
с зажатым Ctrl, происходит показ содержимого, при повторном нажатии, содержимое
опять скрывается.

`MaxLength=`

Определяет максимальную длину вводимой строки в символах.

`VariableName=`

Определяет имя переменной под которой будет значится это поле ввода. Переменную
для этого случая объявлять не нужно. Если ни чего не заданно тогда именование
переменной производится по следующей схеме :

ТипПоляВвода_СвязанноеСНимПоле
 

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
OutBox_Coast
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


>   **Примечание :**

>   При изменении или вводе значений в поля ввода изменяются только связанные с
>   ними переменные.

 

>   Предложения *InputBox=, OutBox=, EditBox=* могут использоваться совместно с
>   предложением *GetValue=* для использования диалога выбора.

 

Поле списка с контекстным поиском
---------------------------------

Представляет собой поле со списком, содержание которого зависит от введённых в
него данных. Отбор по вводимому значению осуществляется по нажатию сочетания
клавиш *Ctrl+Enter*. Для создания такого поля используется команда:

`ContextList=`

Поля списка объявляются в области полей, путем написания после надписи поля типа
компонента. В качестве поля данных указывается поле, содержащее представление
выбираемого значения.

 
**Параметры :**

`ContextListTable=`

Таблица для наполнения списка.

`ContextListField=`

Отображаемое поле в таблице просмотра.

`ContextListKey=`

Ключевое поле в таблице просмотра.

`ContextListData=`

Поле представления данных в НД. Если не указано, приравнивается к значению в
*ContextListField=.*

`SQL=`

Текст запроса представления списка. Является необязательным параметром, если он
не указан, список строится на основе параметров *ContextListTable,
ContextListField, ContextListKey.*

 

Список выбора
-------------

Список выбора представляет собой выпадающий список в поле таблицы при двойном
щелчке на нём или компонент списка в режимах 0 и 1.

`DropListBox=`


>   **Примечание :**

>   Режим списка выбора в режиме 2 (сетка) может работать, только если НД
>   доступен для редактирования, а так же не используется сохранение полей.


**Параметры :**

`List=`

Содержит список значений через запятую. Поддерживаются переменные.

`SetIndexValue=`

Если параметр имеет значение «1», то в поле таблицы заносится индекс выбранного
элемента, а не его строковое значение.

`SQL=`

Параметром для его построения является запрос, возвращающий набор данных из
одного столбца.

Допустимо использование параметров и переменных.


>   **Примечание :**

>   Допускается совместное использование обоих параметров, список будет
>   дополнятся, список указанный в предложении будет иметь больший приоритет и
>   займёт место в начале.

>   Используя системные переменные *\_USERACCESSLEVEL\_* и *\_NOTIFYACTIONS\_*,
>   можно получить список прав пользователей и список действий оповещений,
>   соответственно.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Язык\DropListBox=List=<Нет>,Английский,Немецкий,Французкий,Японский,Арабский;
INOSTR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Поля просмотра
--------------

Поля представляющие список со значениями из таблицы. Этот список подменяет собой
определённые значения другого НД.


>   **Примечание :**

>   Режим полей просмотра может работать, только если режим отображения
>   установлен в 0 или 1 (поля).

>   Все параметры предложения должны оканчиваться знаком «;» точка с запятой.

 

`Lookup=`

**Параметры :**

`SQL=`

Используется для создания набора данных для подстановки к ключевым значениям.

`Key=`

Указывает ключевое поле в таблице выбора, для сопоставления полей просмотра с
полями основного НД.

`List=`

Список значений таблицы выбора, отображаемый на значения поля указанного в
параметре *Key=*.

`VariableName=`

Необязательный параметр, определяет имя переменной в которую будут помещается
значения ключевого поля при его выборе. Объявлять переменную не требуется.
Совместно с директивой *NoDataField=* может использоваться для выбора значений
из списка не в редактируемый набор данных, а в переменную.

`NoDataField=`

Использует поле только для выбора значений в переменную, без занесения их в БД.
Принимает значения 1 -- Да, 0 -- Нет.

`KeyValue=`

Позволяет выставлять значение списка в отсутствии основного набора данных или
если данные не определены. В предложении пишется значение ключевого поля НД для
списка. Поддерживается использование переменных. Возможно указание запроса,
первый столбец которого будет присвоен параметру.

**Необязательные параметры :**

`ModifyingEdit=`

Имя компонента куда будет заноситься значение выбора, помимо изменяемого поля
или вместо него.


>   **Примечание :**

>   Директива *ModifyingEdit=* имеет больший приоритет.


`ReadOnly=`

Делает поля только для чтения.

`Width=`

Задает ширину компонента. Можно использовать математические выражения.

Ниже подписи поля указывается поле, которое будет отображать значения поля
указанного в параметре *List=*.

 

Таблицы просмотра
=================

По сравнению с полями просмотра, таблицы просмотра позволяют просматривать сразу
весь НД, но не имеют возможности подстановки значений. Для их реализации
используется следующее предложение:

`LookupTable=`

Содержит набор следующих директив:


**Параметры :**

`SQL=`

Является обязательным параметром и содержит запрос, строящий таблицу просмотра,
в запросе допускается использовать переменные. Запрос для таблицы должен
соответствовать быть построен по следующим правилам.

В качестве значения для отбора должен стоять параметр, знак двоеточия и имя поля
содержащее значение отбора :

select \* from orders where CustNo=:CustNo

где :CustNo имя поля в главной таблице.

`DependField=`

Поле, связанное с основным набором данных.

`Live=`

Если значение параметра равно *1*, то становится возможным редактирование
таблицы просмотра.

`Columns=`

Позволяет именовать столбцы таблицы произвольно, задавая список полей в виде:

ИмяПоля1/Подпись Поля 1, ИмяПоля2/Подпись Поля 2, ИмяПоля3/Подпись Поля 3.

![](LookupTable.png)
 

Диалоги выбора
==============

Диалоги выбора позволяют выбрать значение из диалога и занести его в поле ввода. 
Для их определения используется нужно создать контекстную кнопку поля, и назначить 
ей команду вызова диалога, в скрипте вызова диалога, необходимо указать режим выбора, 
параметр ChooseMode= принимает значения 1 или 2.

**Параметры :**
	
`Dialog=`

Определяет вызываемый диалог, недопустимо в качестве диалога указывать 	командный скрипт.

`KeyField=`

Указывает поле откуда будет браться выбираемое значение.

`ValueField=`

Указывает поле, откуда будет браться значение подписи.
	
`KeyModifyingField=`

Указывает поле, куда будет заноситься выбранное ключевое значение.

`ValueModifyField=`

Указывает поле, куда будет заноситься выбранное значение.

`KeyEditName=`

Компонент, куда запишется ключевое значение.

`ValueEditName=`

Указывается имя компонента поля ввода для занесения в него значения.

`KeyField=`

Указывает поле, представления данных, из которого возмётся ключевое значение.

`ValueField=`

Указывает поле, представления данных, из которого возмётся значение подписи.
 


Компонент «Переключатель»
=========================

Имеет два положения «Взведено» и «Снято», соответственно возвращает 1 и 0.

Для создания используется предложение :

`CheckBox=` и `SimplyCheckBox=`, `DBCheckBox=`

которое, аналогично полям ввода, пишется после надписи поля через знак «\\».
*CheckBox=* и *SimplyCheckBox=*, создаёт компонент, не связанный с набором
данных.
 

**Параметры :**

`VariableName=`

Задаёт переменную для помещения значений выбора.

`_OnCheck;`

Создаёт переключатель включенным.


**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Fields]
2
Статус\ CheckBox= VariableName=Status;_OnCheck;
Stat
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Компонент «Ползунок»
====================

Поле «Ползунок», представляет собой, ползунок с возможностью регулировки и таким
образом, выставления нужного значения, в заданном диапазоне. Объявление
компонента производится, так же как и других компонентов-полей, через знак \\
после имени поля.

`RollBar=`

**Параметры :**

`_Min=`

Задаёт минимальное значение. Возможно использование математических выражений.

`_Max=`

Задаёт максимальное значение. Возможно использование математических выражений.

`_VariableName=`

Необязательный параметр. Имя переменной, в которую будет заносится значение
позиции ползунка. Объявлять переменную не нужно. Если же переменная объявлена, а
компонент не смязан с полем данных, подстановка значения позиции произведётся из
переменной.
 

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Fields]
1
Уровень доступа\RollBar=_Min=0;_Max=!!Count(&USERNAMEACCESSLEVELS)-1;
ACCESSLEVEL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В предлагаемом примере, числовое значение уровня доступа, выбирается ползунком,
начиная от 0 до значение возвращаемого функцией Count() и аргументом указанным в
ней, минус 1.

 

Элемент «Поле картинки»
=======================

Элемент управления «Поле картинки», представляет собой, поле с изображением и
элементами манипулирования им, в области таблицы, а так же загружать изображения
формата BMP и JPEG.

Для его построения используется предложение:

`DBImage=`

 

**Параметры :**

`FieldName=`

Задаёт имя поля связанного с ним.

`ReadOnly=`

При значении равном «1», поле будет не доступно для редактирования.

 

Элемент «Поле текста» и «Поле форматированного текста»
======================================================

Эти элементы управления могут отображать большой объём текста и форматированный
текст, соответственно.

Для построения поля текста используется предложение :

`DBText=`

Для создания поля форматированного текста используется предложение :

`DBRichText=`

Параметры обоих предложений аналогичны параметрам элемента «Поле картинки».

![](ImageBox.png)

 

Команды
=======

`Exit;` (C)

Закрывает приложение.

`SetMainFormCaption=` (C)

Устанавливает заголовок на главной форме, допускается использовать параметры и
переменные.

`SetFormCaption=` (C)

Устанавливает заголовок диалога, допускается использовать параметры и
переменные.

`ApplicationTitle=` (C)

Устанавливает заголовок приложения в панели задач, допускается использовать
параметры и переменные.

`CloseDialog;` (C)

Закрывает текущий диалог.

`ApplicationTitle=` (V, C)

Устанавливает заголовок приложения в панели задач, допускается использовать
параметры и переменные.

`ExecCommand=` (V, C)

Запуск командного скрипта. Допускается использование параметров и переменных.

`Insert;` (V, C)

Вставляет пустую запись.

`Insert_Part;` (C)

Вставляет пустую запись в табличную часть.

`Delete;` (V, C)

Удаляет текущую запись.

`Delete_Part;` (C)

Удаляет текущую запись в табличной части.

`DeleteConf;` (C)

Удаляет текущую запись, но с подтверждением.

`DeleteConf_Part;` (C)

Удаляет текущую запись в табличной части, но с подтверждением.

`Append;` (V, C)

Добавляет в конец БД новую запись.

`Append_Part;` (C)

Добавляет в конец БД новую запись в табличной части.

`Edit;` (V, C)

Переводит БД в состояние редактирование

`Edit_Part;` (C)

Переводит БД табличной части в состояние редактирование

`Post;` (V, C)

Сохранение изменений в поле.

`PostClose;` (V, C)

Сохранение изменений и закрытие диалога.

`Post_Part;` (C)

Сохранение изменений в поле в табличной части.

`First;` (V, C)

Переход на начало НД.

`First_Part;` (C)

Переход на начало НД в табличной части.

`Prior;` (V, C)

Переход на предыдущую запись.

`Prior_Part;` (C)

Переход на предыдущую запись в табличной части.

`Next;` (V, C)

Переход на следующую запись.

`Next_Part;` (C)

Переход на следующую запись в табличной части.

`Last;` (V, C)

Переход в конец НД.

`Last_Part;` (C)

Переход в конец НД в табличной части.

`CurrentTablePart=` (V, C)

Устанавливает активной табличную вкладку с номером заданным в параметре. Счёт
ведётся с *1*. Допускается использование переменных и параметров. Можно
использовать математические выражения. При значении равном *-1*, делает текущей
последнюю ТЧ. Команда действует для текущей странице в визуальном скрипте и для
текущей открытой в командном.

`PostRefresh;` (C)

Выполняет команду Сохранить и Обновить на основном НД.

`Cancel;` (V, C)

Отменяет все не сохранённые изменения в БД командой Post.

`CancelClose;` (C)

Отмена не сохранённых изменений и закрытие диалога.

`Cancel_Part;` (C)

Отменяет все изменения в БД табличной части.

`Refresh;`

Обновить.

`Refresh_part;`

Обновляет все табличные части на форме.

`Connect;`

Устанавливает вновь связи с БД. Используется после применения команды
Disconnect.

`Disconnect;`

Разрывает связь с БД.

`StartTransaction;`

Начинает транзакцию.

`Commit;`

Фиксация изменений в БД и завершение транзакции.

`Rollback;`

Производит откат транзакции и возврат БД в состояние до вызова
`StartTransaction;`.

`Fetch;` (BDE)

Производит чтение НД до конца.

`Debug;`

Позволяет просматривать выполняемые команды в режиме отладки.

`Print;`

Выводит на печать НД без учета именования столбцов.

`PrintGrid;`

Выводит на печать таблицу.

`Execute=`

Запуск приложения указанного в предложении.

 

**Параметры:**

`WorkDir=`

Рабочая папка.

`Wait=`

Принимает значения «1» или «0» - по умолчания. Если директива

присутствует и имеет значение «1», то после запуска внешнего приложения,
происходит ожидание завершения запущенного приложения. Может использоваться для
ожидания получения, каких либо данных или совершения, каких либо действий.

`ShellExec=`

Позволяет запускать не исполняемые файлы, например открыть документ PDF.
Параметр невозможно использовать совместно с параметром Wait.

`Sleep=`

Задержка в миллисекундах. Поддерживаются параметры и переменные для подстановки
значения. Можно использовать математические выражения.

`Beep;`

Одиночный звук из системного динамика.

*Beep=Частота, Продолжительность*

Звук заданной частоты и длительности. Поддерживаются переменные и параметры.

`DownLoadHTTP=`

Закачка файла с возможностью докачки. В качестве параметра указывается URL
файла. Поддерживаются переменные и параметры.

 
**Параметры :**

`FileName=`

Имя выходного файла.

`Path=`

Путь для сохранения файла с тем же именем что и в ссылке, имеет приоритет ниже

чем у параметра `FileName=`.

`Reset=`

Если равно «1», закачивать с начала. По умолчанию докачка включена.

`Progress=`

Показывать прогресс загрузки.

`Cancel=`

Показывать кнопку «Отмена».

`GotoKey=`

Переход на значение в таблице, заданное в предложении и полем заданным в
параметре. Поддерживаются переменные и параметры. Указывается список значений
через запятую.

 
**Параметры :**

`KeyField=`

Список ключевых полей, через запятую.

`SetFieldValue=` (V, C)

Присваивает полю значение, значения должны быть следующего вида,
*Поле=Значение*.

Допускается указывать несколько пар вида Поле=Значение через запятую а, так же
использовать переменные.

 
**Параметры :**

`Post=`

Может принимать значение 1 или 0. Если 1 то происходит автоматическая фиксация
изменений в БД.

`Commit=` (BDE)

Может принимать значение 1 или 0. Если 1 то происходит автоматическая
окончательная фиксация изменений в БД. Действует только если используется
кэширование изменений (Директива *CashBase=1* или Используется предложение
*UpdateQuery=*).

`TablePartNum=`

Устанавливает номер табличной части, счет ведётся с единицы. Можно использовать
математические выражения.

 
>   **Примечание :**

>   Соблюдение типов для команды не требуется.

 
Данная команда будет работать тогда, когда НД является редактируемым или
используется предложение *UpdateSQL=*. Для иных случаев используется предложение
ModifyingQuery с переменными и/или параметрами и/или с полями ввода.

`GetFieldValue=`

Присваивает переменной значение из поля, значения должны быть следующего вида,
*Переменная=Таблица.Поле*

Таблицу можно не указывать, если это, просматриваемый (текущий) НД. Тогда
значение будет браться из текущей записи.

Допускается указывать несколько пар вида *Переменная=Таблица.Поле* через
запятую.

 
**Параметры :**

`Where=`

Устанавливает условие отбора единственной записи из таблицы.

`SQLMon;` (C)

Включает/отключает SQL трассировку в файл.

`SQLMon_Clear;` (C)

Очищает лог SQL трассировки.

`Forward=` (C)

Задает метку для немедленного перехода вперед.

`Goto=` (C)

Задает метку для немедленного перехода на нее. Метка задаётся форматом:

`:Метка;`

`Return;` (C)

Осуществляет возврат к месту от которого произошёл переход по команде *Goto*.

`Break;` (C)

Завершение выполнения текущего скрипта.

`OpenFileDialog=` (C)

Вызывает стандартный диалог открытия файла, результат выбора попадает в
переменную указанную в параметре.

 
**Параметры :**

`Ext=`

Задаёт расширение по-умолчанию.

`SaveFileDialog=` (C)

Вызывает стандартный диалог сохранения файла, результат выбора попадает в
переменную указанную в параметре.

 

**Параметры :**

`FileName=`

Определяет имя файла, заносимое по умолчанию.

`Ext=`

Задаёт расширение по-умолчанию.

`PutToDB=`*,* `GetFromDB=` (C)

Первая команда поместит файл в базу, вторая извлечёт данные из базы в файл. Для
этого поля базы данных должно быть типа BLOB. У команд есть следующие параметры:

 
**Параметры :**

`DataField=`

Поле, содержащие данные.

`SQL=`

SQL запрос, формирующий набор данных из одной записи.

`FileName=`

Имя файла, позволяет указывать в качестве значения параметры и переменные. При
использовании директивы SQL=, возможно применять параметры НД получившегося в
результате работы этого запроса.

`Compress=`

Принимает значение «1», если требуется компрессия. Осуществлять сжатие
помещаемых данных, для извлечения, не потребуется никаких действий, определение
того, что данные сжаты, производится автоматически.

`MD5Data=`

Вычисление контрольной суммы MD5 на основе данных из хранилища, после равно
указывается переменная, куда будет помещён результат. Остальные параметры
аналогичны командам *PutToDB*, *GetFromDB.*

`CompressData=, DecompressData=`

Сжатие и распаковка данных в базе. Параметры аналогичны командам *PutToDB*,
*GetFromDB*.

 
**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CompressData=SQL=select * from DCL_TEMPLATES where TEID=:TEID;DataField=TEMPL_DATA;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Данные, находящиеся в таблице и спозиционированные в диалоге, будут сжаты.

`ClearBLOB=` (C)

Производит очистку данных, хранящихся в поле. Параметры аналогичны командам
*PutToDB*, *GetFromDB*.

`OpenFolder=`

Открывает указанную папку. Можно указывать переменные и процедуры.

`Lock;`

Блокирует рабочую среду, скрывая все окна и выводя окно с паролем, при
правильном вводе пароля окно авторизации исчезает и окна появляются снова.
Разблокировать свой сеанс может только вошедший в рабочую среду пользователь.
Можно также, войти с другим пользователем, главное меню при это, приобретёт вид
как у вошедшего в систему пользователя.

`Hold;`

Производит запрет переключения форм, а соответственно и контекста. Желательно
использовать перед выполнением каких либо длительных процессов, а в особенности,
процессов использующих основной НД для своей навигации.

`HoldDown;`

После команды Hold;, непременно должна следовать команда `HoldDown;`, что бы
вернуть нормальный режим работы программы.

`WriteConfig=`

Производит запись параметра в
[Т](#Таблица_глобальных_параметров)[Г](#Таблица_глобальных_параметров)[П](#Таблица_глобальных_параметров).
Сразу после равно указывается имя параметра.

 
**Параметры :**

`UserID=`

Не обязательный параметр, позволяет читать и записывать параметры привязанные к
конкретному пользователю. Параметр обязательно должен идти перед параметром
*\_Value=*.

`_Value=`

Значение параметра, допустимо указывать любые символы. Обязательно должен быть
последним.

 
>   **Примечание :**

>   Все команды без параметров оканчиваются знаком «;» точка с запятой.

 

Переменные среды
================

Переменными среды, называются команды, устанавливающие какие либо глобальные
параметры. У некоторых из этих команд существуют аналоги в файле инициализации
(DCL.ini), обозначены символом (I).

`AddPassword=` (BDE)

Добавляет пароль в сессию для открытия таблицы. Применяется только для таблиц
Paradox.

`RemovePassword=` (BDE)

Удаляет пароль из сессии для открытия таблицы. Применяется только для таблиц
Paradox.

`RemoveAllPasswords;` (BDE)

Удаляет все пароли из сессии. Применяется только для таблиц Paradox.

`DisableParams=`

Запрещает или разрешает интерпретацию параметров. Принимает значение 1-включено
или 0-выключено.

`SeparateChar=` (V, C)(I)

Устанавливает символ для обозначения строк/дат.

`SetValueSeparator=` (V, C)(I)

Производит установку разделителя выбранных значений через диалог выбора.

 

Командные кнопки
================

Командные кнопки вызывают скрипты, с тем же контекстом что и форма. Однако
последующий вызов диалога, без параметра *Child=1*, прерывает эту цепочку.

Для создания командных кнопок используется предложение *CommandButton* имеющее
следующие параметры.

**Параметры :**

###### `CommandName=`

Определяет имя скрипта, выполняемой команды, в этом случае параметр *Action=*
должен отсутствовать. Допускается указание только командных скриптов. Если же
это короткая команда, то можно указать её прямо в этой директиве.

#### `Label=`

Определяет заголовок кнопки.

`Hint=`

Определяет всплывающую подсказку.

`Width=`

Задаёт ширину кнопки в пикселях.

`_Default=`

Если равно 1 то кнопка активируется по нажатию Enter.

`_Cancel=`

Если равно 1 то кнопка активируется по нажатию Escape.

`FontStyle=`

Задает стиль шрифта кнопки.

 
**Параметры :**

-   *Bold* -- Жирный шрифт.

-   *Italic* -- Курсив.

-   *UnderLine* -- Подчеркнутый.

 

Параметры могут комбинироваться через запятую.

`AccessLevel=`

Уровень прав для отображения кнопки, указывается число [соответствующее](#Права)
уровню прав пользователя. Учитывается уровень права, действующего в пределах
текущего диалога. Допустимо указывать переменные и функции.

`Action=`

Назначает предопределенное действие или выполняет одну команду (команды см.
ниже).

 
**Действия :**

`Refresh`

Позволяет обновить НД, методом *Refresh*.

`Delete`

Удаляет текущую запись.

`DeleteConf`

Удаляет текущую запись, но с подтверждением.

`Post`

Сохранение правки поля, если не было перехода на другую запись.

`PostClose`

Сохранение и закрытие диалога.

`Cancel`

Отменить.

`CancelClose`

Закрытие и отмена несохранённых изменений.

`Insert`

Вставляет пустую запись.

`Append`

Добавляет пустую запись.

`Version`

Возвращает версию платформы.

`Close`

Закрывает форму.

`ClearAllContextFilters`

Очистить все контекстные фильтры.

`Pict=`

Устанавливает картинку. Не применяется совместно с директивой *Action=*.
Картинки можно загружать из хранилища двоичных значений, указывая имя значения.
Картинки должны быть в формате BMP. Цвет левого верхнего пикселя, указывает
прозрачный цвет.

 
**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CommandButton=Label=Пометить;CommandName=DeleteDoc;Pict=Delete;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом примере создается кнопка с заголовком "Пометить" и при ее нажатии будет
выполнятся скрипт с именем "DeleteDoc" и устанавливает картинку в значении
Delete из хранилища двоичных объектов.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CommandButton=Action=Dialog=Clients;Label=Клиенты;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вызывает диалог Clients.

 

Команды инициализации
=====================

Непосредственно после запуска приложения, иногда требуется выполнить какие либо
команды. Для этого используются идентификаторы от *40001* по *40100*
включительно. Команды могут быть как визуальными, так и командными скриптами,
для командных скриптов в его начале должен быть проставлен тип скрипта
директивой

`script type=command`. Внутри скриптов возможно также запускать другие командные
скрипты, посредством предложение `ExecCommand=`.

>   **Примечание :**

>   Недопустимо использовать в этих скриптах команды, оперирующие с визуальными
>   компонентами или использовать НД визуальных форм. Например, команды
>   *GlobQuery*, *ExecQuery*.

 

Команды момента завершения
==========================

Иногда, требуется выполнить какую либо команду непосредственно перед закрытием
приложения, для этого служат скрипты с идентификаторами от 40101 до 40200. все
описанное в теме Команды инициализации относится так же и к текущей теме.

 

Переменные
==========

Переменные это -- заранее объявленные, именованные значения в скрипте, значения
которых можно подставлять в запросы и сообщения и вообще использовать где
угодно. В DCL5 различаются локальные переменные, которые доступны только в
области формы в которой она объявлена. И глобальные, видимые из любого места
конфигурации.

Для объявления переменных служит предложение :

`Declare=`

Для объявления локальных переменных:

`LocalDeclare=`

в котором указывается выражение вида : Переменная[=значение]. Для обращения к
значениям переменным осуществляется через знак «&».

Уничтожение переменных осуществляется командой *Dispose=Имя_переменной*,
распространяется только на глобальные переменные. При повторном объявлении или
использовании переменной в компоненте, её значение сбрасывается.

 
**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Declare=OutDate="01.12.2004",DocName;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`....`

`Dispose=OutDate, DocName;`

В данном примере создаются переменные OutDate и DocName, переменной OutDate
присваивается значение, затем переменные уничтожаются. В предложении Declare и
Dispose допускается указывать несколько переменных через запятую.

 

>   **Примечание :**

>   При явном или неявном объявлении переменной, её значение сбрасывается.

>   Всегда уничтожайте ненужные переменные, что бы не запутаться.

>   При трансляции значения переменной, первый приоритет имеют локальные
>   переменные, если имеется локальная переменная, с тем же именем что и
>   глобальная, то произойдёт подстановка её значения.

>   Допустимо указывать переменные в тексте без отделения их от другого текста.

 
**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Declare=EnumType, GoodMsg;
...
SetValue=EnumType=штук;
....
SetValue= GoodMsg =Товар №&ItemNum, в количестве :ItemCount &EnumType имеется в наличии;
Declare=v1=Hellow!;
Message=&v1;
LocalDeclare=v1=Good bye!;
Message=&v1;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

При исполнении этого скрипта произойдёт следующее: Выведется «Hellow!»,
выведется «Good bye!», так как значение локальной переменной, с тем же именем,
объявленной после вывода глобальной, имеет больший приоритет.

`SetValue=` (V, C)

Присваивает переменной значение. Если же переменной требуется присвоить
значение, возвращаемое запросом из таблицы, тогда используются директивы :

 
**Параметры :**

`SQL=`

Запрос возвращающий требуемое значение.

`ReturnField=`

Поле с возвращаемым значением, если не указанно, то используется первое по счету
поле.

 
>   **Примечание :**

>   Допускается использование параметров и переменных.

>   Внутри этого предложения можно использовать только одну пару
>   *Переменная=Значение*.

 
`TablePart=`

Если данные требуется брать из табличной части, то в этой директиве указывается
номер табличной части или *0* если данные нужно брать из текущей. Можно
использовать математические выражения.

 
>   **Примечание :**

>   Допустимо присвоение значений параметров переменным, но не наоборот.

>   Параметры и переменные являются безтиповыми, поэтому следите за

>   соблюдением типов при использовании переменных в SQL выражениях.

>   При изменении значения переменной меняется соответствующее ей поле ввода и
>   наоборот.

 

Системные переменные (константы)
--------------------------------

Помимо переменных, объявляемых в тексте скрипта, существую системные переменные,
их не надо объявлять и задавать им значение, а после уничтожать, их значение
предопределено и они всегда существуют. Это могут быть переменные, возвращающие
время, дату, и т.д. Обращение к их значениям производится как к обычным
переменным, через знак «&».

-   \_DATE_: Возвращает текущую дату.

-   \_TIME_: Возвращает текущее время без секунд.

-   \_TIMES_: Возвращает текущее время с секундами.

-   \_DATETIME_: Возвращает текущую дату и время с секундами.

-   \_ISEMPTY_: Возвращает "1" если НД пуст, и "0" если есть хоть одна запись.

-   \_VERSION_: Возвратит версию модуля.

-   \_FULLVERSION_: Возвратить версию в формате «ХX.XX.ХX.ХX».

-   \_DCLINI_: Используемый *DCL.ini*, имя файла с путём.

-   \_DCLTABLE_: Возвращает имя таблицы со скриптами.

-   \_DCLNAMEFIELD\_ : Возвратит поле с именем скрипта из таблицы скриптов.

-   \_DCLTEXTFIELD\_ : Возвратит поле с текстом скрипта из таблицы скриптов.

-   \_IDENTIFYFIELD\_ : Возвратит поле идентификатора из таблицы скриптов.

-   \_PARENTFLGFIELD\_ : Возвратит поле родителя из таблицы скриптов.

-   \_COMMANDFIELD\_ : Возвратит поле с командой из таблицы скриптов.

-   \_NUMSEQFIELD_: Поле, содержащее идентификатор элемента меню.

-   \_USERNAME\_ : Возвращает имя пользователя БД.

-   \_PASSWORD\_ : Возвращает пароль БД.

-   \_ALIAS_: Алиас БД.

-   \_STRINGTYPECHAR\_ :Ограничитель строк.

-   \_VALUESEPARATOR\_ : Возвратит текущий разделитель выбранных значений.

-   \_ROLESTABLE_:Таблица ролей.

-   \_ROLESMENU_:Таблица элементов меню ролей.

-   \_ ROLEIDFILED_:Поле с идентификатором роли.

-   \_ROLENAMEFIELD_:Поле с именем роли.

-   \_ROLEMENUIDFIELD_:Поле с идентификатором роли в таблице элементов меню
    ролей.

-   \_MENUITEMID_:Поле в таблице элементов меню содержащее номер элемента.

-   \_ROLENAME_:Имя роли.

-   \_LONGROLENAME\_ :Полное имя роли, если не указанно значение параметра
    LongRoleNameField в файле настройке, то подразумевается что, этого поля нет.

-   \_ROLEID_:Идентификатор текущей роли.

-   \_USERPASS_:Введенный пароль пользователя.

-   \_FOB_: Возвратит «1» если начало НД.

-   \_EOB_: Возвратит «1» если конец НД.

-   \_OS_: Возвратит операционную систему (*windows или posix=(Linux, BSD)*).

-   \_MAC_: Возвратит MAC адрес первого сетевого устройства.

-   \_APPPATH_: Возвратит путь к программе с разделителем папок в конце.

-   \_APPDATAPATH_: Возвращает путь к папке программы в *%AppData%\\DCL5\\* для
    Windows и *\~/.config/DCL5/* для Linux. В неё помещаются временные файлы и
    файлы настройки. Эта папка может быть переопределена с помощью параметра
    *UserLocalProfile=* в конфигурационном файле или в таблице глобальных
    параметров.

-   \_USERPROFILE_: Возвратит папку *%AppData%* для Windows и домашнюю
    директорию для Linux.

-   \_USERDOC_: Возвратит папку *«Мои документы»* для Windows и домашнюю
    директорию для Linux.

-   \_ENGINETYPE_:Метод доступа к данным, (BDE, ADODB, IB, ZEOS).

-   \_CURRENTSTRING_: Возвращает номер выполняемой строки.

-   \_SCRIPTRESULT\_ : Содержит результат выполнения скрипта
    [VBScript](../HYPERLINK#VBS).

-   \_DCL_USER_NAME_: Возвратит имя текущего пользователя, вошедшего в
    программу.

-   \_DCL_USERS_TABLE_: Таблица пользователей системы.

-   \_USERID_:Идентификатор пользователя вошедшего в систему.

-   \_USERNAMEACCESSLEVELS_: Список прав пользователей.

-   \_USERACCESSLEVEL_: Числовое значение права пользователя вошедшего в
    систему.

-   \_NOTIFYACTIONS_: Список действий оповещения.

-   \_YESNO_: Список вида: «Нет, Да».

-   \_EVALFORMULA_: Результат вычисления математического выражения.

-   \_DSSTATE_: Числовой индекс статуса набора данных.

-   \_DSSTATENAME_: Название статуса набора данных.

-   \_ROLEACCESSLEVEL_: Уровень прав роли.

-   \_FULLRAIGHTS_: Полное право текущего пользователя, в соответствии с правом
    роли.

 
**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Setvalue=OutDate="12.01.2005";
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В указанном примере переменной OutDate присваивается значение "12.01.2005".

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Setvalue=Today=&DATE;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В указанном примере переменной OutDate присваивается значение текущая дата.

`Setvalue=OutDate=&Today;`

В этом примере переменной OutDate присваивается значение переменной Today.

`SetValue=SC;ReturnQuery=select gb.paramvalue from global_params gb where
gb.paramname='SumComiss';`

Здесь переменной SC присваивается значение возвращаемое запросом.

 

Логические выражения
====================

Под логическими выражениями в DCL5 понимается выражение заданное двумя
предложениями и одним знаком, результатом его служит выборочное выполнение тех
или иных строк скрипта.

В целом логическое выражение должно иметь следующий вид :

`If [Expression1=Значение или SQL выражение; Expression2= Значение или SQL
выражение; Sign=знак;]|[Логическое<>условие] then`

`<Блок действие если`

`выражение верно>`

`Else`

`<Блок действие если`

`выражение не верно>`

`EndIf`

 
**Параметры :**

`Expression1=`

Задает часть выражения. Для последующего сравнения его с результатом в
предложении *Expression2=*.

`SQL=`

Параметр предложения ExpressionX, задает SQL выражение для возврата значения для
сравнения.

`ReturnField=`

Определяет, в каком поле находится значение для сравнения.

`Sign=`

Задает логический знак для сравнения значений параметров Expression1= и
Expression2=. Если параметр не задан, то подразумевается знак «равно».

 
>   **Примечание :**

>   Для расчёта результата можно использовать предложение *Evalute=,* делая
>   логическое сравнение, результатом будет «True» или «False», которые можно
>   подставить в ExpressionX=.

>   Для простых условий без использование SQL выражений, допустимо просто
>   указание логического условия без использования директив ExpressionX=.

 
**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If Expression1=SQL=select DateOD from "db\DatesOD" where CurrentFlag=1; Expression2=&DATE; then
Dialog=InputNewDocs;
Else
Message=Дата ОД не соответствует сегодняшней дате!;
EndIf
Evalute=&Price*118<&LimitSum;
If &SCRIPTRESULT=True then
Dialog=Нужно добавить что то ещё;
EndIf
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
>   **Примечание :**

>   Выражение, задающее условие, должно непременно, содержаться только в одной
>   строке.

>   Логические выражения могут исполнятся, только из командных скриптов, для
>   запуска их из визуальных используйте предложение *ExecCommand=* содержащее
>   вызов скрипта с логическим выражением.

>   Не поддерживается вложенные логические выражения.

 

Использование математических выражений
======================================

В DCL возможен расчёт простых математических выражений, а так же использование
их в некоторых свойствах компонент.

Для расчёта выражения существует предложение :

EvalFormula=

Оно производит вычисление заданной формулы и помещает её результат в системную
переменную *\_EVALFORMULA\_*.

Для использования математических выражений в числовых свойствах компонент,
достаточно просто, там где это возможно, указать формулу и результат её расчёта
подставится в свойство.

 

Использование языка VBScript
============================

Язык VBScript, является универсальным алгоритмическим языком программирования,
позволяющим производить вычисления любой сложности и использовать простые
визуальные элементы ввода и отображения значений.

 

Скрипты на языке VBScript
-------------------------

В DCL5 поддерживается исполнение скриптов на языке VBScript.

Существует несколько способов запуска скриптов:

-   Предложение `Evalute=`. Для непосредственного запуска доступны только
    выражения в предложении *Evalute=*. Все процедуры и функции, исполняющие
    какие либо действия, должны быть заранее определены и загружены предложением
    `AddFunctions=`.

-   Запуск скрипта с директивой `Script Type=VBScript` или через предложение
    `ExecVBS=`. В этом случае произойдёт обычное его исполнение, возможно так же
    объявить в нём процедуры и функции и вызывать их.

 
`Evalute=`

Исполняет код в предложении, возвращая результат.

**Параметры :**

`ResultVar=`

Переменная для помещения результата, если не указана, результат доступен в

системной переменной *\_SCRIPTRESULT\_*.

`AddFunctions=`

Добавляет в пул кода объявленные функции, не исполняя их. Параметром служит имя
скрипта, содержащий сами функции.

`ExecVBS=`

Исполняет произвольный VBS код, без возврата результата.

Во всех предложениях поддерживается трансляция переменных и параметров.

 

Вывод в файл
============

Для вывода текста в файл служит команда

`Spool=`

Для начала вывода в файл нужно проинициализировать командой `OpenSpool=`, где
параметром служит имя файла. Всё что будет указанно в команде *Spool=* будет
выведено в файл.

 

Выгрузка данных
---------------

Для выгрузки информации используется предложение *Export=*. Выгрузка может
осуществляться в четырех форматах, которые будут перечислены ниже.

**Параметры :**

`Target=`

Определяет формат выгрузки данных, может принимать следующие значения ниже.

`Source=`

То же что и *Target=*, применяется соответственно для загрузки данных.

`Mode=`

Режим добавления, если не задан, то используется значение *New*, создающее новый
файл, если же нужно производить добавление тогда используется значение параметра
*Append*.

`Filename=`

Имя файла без расширения, для выгрузки.

`Table=`

Указывает таблицу куда будут в последствии (!)загружаться(!) данные.

`Query=`

Создает конечный НД для выгрузки или загрузки.

`Spool=`

Если равно 1, то будет происходить перенаправление вывода в файл, аналогично
команде *Spool=*.

 

### Форматы выгрузки/загрузки

Поддерживаются пять форматов выгрузки и четыре загрузки данных.

-   DBF -- Windows dBase.(BDE)

-   PDX -- Windows Paradox.(BDE)

-   SQL -- Стандартный SQL, используются конструкции вида insert into.

 

Создание отчётов в офисных пакетах Microsoft Office или Open Office
===================================================================

Платформа DCL5 поддерживает создание отчётов в обеих офисных пакетах, притом
разработчику не нужно знать заранее, какой офисный пакет будет установлен на
рабочем месте пользователя, создание отчёта будет производиться в имеющимся
офисном пакете.

Предложения *ReportExcel и ReportOOCalc*, а также *ReportWord* и
*ReportOOWriter* оставлены для совместимости, но использовать их в новых
проектах не рекомендуется.

При использовании офисного пакета Open Office, формат шаблонов и сохраняемых
документов может быть разный и указывается в глобальных настройках или в ini
файле.

Для всех предложений допустимо использование параметров, переменных и процедур.

 

Экспорт данных в Excel и OpenOffice.Calc
----------------------------------------

Для экспорта в Excel и OpenOffice.Calc используется, предложение :

`ReportOfficeSheet=` (C)

Если на компьютере, где формируется отчёт, не установлен пакет Microsoft Office,
то отчёт будет формироваться в OpenOffice.Org, если не указан явный тип офисного
пакета.

**Параметры :**

`OfficeType=`

Тип офисного пакета, указывается латинскими буквами: oo -- OpenOffice, mso --
Microsoft office.

`Template=`

Путь к файлу шаблону, им может быть и обычная
книга. В случае использования имени шаблона, он указывается через директиву :

`TemplateName=`

Имя шаблона в таблице шаблонов. Используется совместно с `Template=`,
для указания пути к файлу.
Допускается использовать переменные и параметры.

`FileName=`

Имя выходного файла.

`Save=`

Сразу сохранять документ после формирования.

`Close=`

Сразу закрывать документ после формирования, может быть использован совместно с
параметром *Save*.

`SQL=`

Запрос, определяющий положение столбцов и создающий собственно НД который
помещается в книгу. Допускается использовать переменные и параметры. Если
параметр будет не указан то, будет использоваться запрос из просматриваемого НД.

`ToPDF=, ToHTML=`

Если в качестве значения параметра стоит «1», то производится экспорт в
соответствующие форматы.

`AlternationRowBackColor=`

Используется для указания цвета фона чередования строк, цвет указывается в
шестнадцатеричном формате вида ККЗЗСС.

`AlternationColBackColor=`

Используется для указания цвета фона чередования колонок, цвет указывается в
шестнадцатеричном формате вида ККЗЗСС.

Файл шаблона должен содержать ячейку с именем DATA, в неё будет выеден левый
верхний угол НД.

![](DATAArea.png)

 

Построение отчётов в MS Word и OpenOffice.Writer
------------------------------------------------

В качестве платформы построения отчётов в DCL5 возможно использовать текстовые
редакторы MS Word и OpenOffice.Writer. В качестве шаблонов используются
документы в формате MS Word с расширением .doc и OpenOffice.Writer с расширением
odt, формат можно указать в настройках модуля. В местах, где предполагается
вывод значений, следует расставить закладки с именами, в точности повторяющие
имя поля в НД, создаваемом через директиву SQL=.

`ReportOfficeText=`\* \*(C)

**Параметры :**

`OfficeType=`

Тип офисного пакета, указывается латинскими буквами: oo -- OpenOffice, mso --
Microsoft office.

`Template=`

Путь к файлу шаблону, им может быть и обычная
книга. В случае использования имени шаблона, он указывается через директиву :

`TemplateName=`

Имя шаблона в таблице шаблонов. Используется совместно с `Template=`,
для указания пути к файлу.
Допускается использовать переменные и параметры.

`Save=`

Сразу сохранять документ после формирования.

`Close=`

Сразу закрывать документ после формирования, может быть использован совместно с
параметром *Save*.

`SQL=`

Запрос, определяющий положение столбцов и создающий собственно НД который
помещается в соответствующие метки документа. Допускается использовать
переменные и параметры. Если параметр будет не указан то, будет использоваться
запрос из просматриваемого НД.

`Layot=`

Принудительное указание стиля шрифта при заполнении метки. Формат задаётся в
следующем виде:

ИмяМетки/СтильШрифта/Размер/Прописью

Секции должны обязательно разделяться знаком “/”.

*ИмяМетки* -- задаётся имя замещаемой метки.

*СтильШрифта* -- Указываются стили начертания шрифта по следующие правилам:

B -- **жирный**;

I -- *курсивный*;

U -- *подчёркнутый*;

S -- зачёркнутый;

C -- по центру;

Стили можно компоновать, указывая их вместе, например так: **BI**.

*Размер* -- указывается размер шрифта.

*Прописью* -- Если число следует написать прописью то ставиться буква W.

**Пример :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Layot=SumPay/BI/14/W;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выведет в метку *SumPay* текст суммы прописью, жирным, курсивным шрифтом,
размером 14.

`ToPDF=, ToHTML=`

Если в качестве значения параметра стоит «1», то производится экспорт в
соответствующие форматы.

 

Отчёты
======

DCL5 позволяет создавать текстовые печатные формы. Для описания отчета
используются специальные структуры, размечающие область запроса, повторяющегося
печатного образа, заголовка и т.д. Для отчетов зарезервированы идентификаторы от
*30000* до *40000*.

 

Секции
------

`[INIT REP]`

`[END INIT]`

Секция содержит начальные действия во время запуска отчета, здесь возможно
объявить переменную, и вызвать диалог для ввода ее значения. В секции разрешены
следующие команды:

 

**Команды :**

`DeclareVariable=`

Объявляет переменную с именем указанным после равно. Допускается указывать

только одну переменную в одном предложении.

`GrabValue=`

Позволяет вводить произвольные значения переменной, указанной после знака равно.
Это правило верно и для последующих предложений ввода значений.

 

**Параметры :**

`Long=`

Определяет максимальную длину вводимого текста.

`DefaultValue=`

Исходное значение. Возможно указывать переменные.

`GrabDate=`

Позволяет выбрать дату с помощью календаря.

`GrabValueFromBase=`

Вызывает форму для выбора значения переменной из базы.

**Параметры :**

`SQL=`

Содержит запрос для построения НД и использования его для выбора

значений. Для отображения значений берется первое по счету поле, а для
подстановки следующее, если поле одно, то оно используется дважды.

`GrabValueList=`

Позволяет выбрать значение из заранее определенного списка.

**Параметры :**

`ListValues=`

Через запятую перечисляются значения списка.

Для всех команд существует директива *Label=*, определяющая текст надписи, если

она отсутствует, тогда будет выводится имя переменной.

`[GLOBALQUERY]`

`Текст запроса`

`[END GLOBALQUERY]`

Создает НД, из которого будут браться данные для построения отчета. Является
необязательной секцией и в случае ее отсутствия в качестве НД берется основной.

Допустимо использование переменных.

`[PARAMS]`

`:ИМЯ_ПАРАМЕТРА`

`SQL=Текст запроса`

`:ИМЯ_ПАРАМЕТРА`

`SQL=Текст запроса;{ReturnField=Поле с результатом}`

`:ИМЯ_ПАРАМЕТРА`

`ReturnValue=Возвращаемая строка.`

`[END PARAMS]`

Секция параметров, если в отчете встречается параметр, то он заменятся на
соответствующее значение. Возможно создание изменяемых параметров, для этого
отчету присваивается идентификатор в диапазоне от 30000 до 40000, а параметры
создается непосредственно в таблице скриптов с указанием в поле принадлежности к
родителю, идентификатора отчета. А секция параметров в этом случае может
отсутствовать или содержать не изменяемые параметры.

С помощью параметров с предложением SQL= можно выводить таблицы целиком, будут
выведены все поля и записи созданного НД.

`[HEADLINE]`

`Текст`

`* заголовка*`

`[END HEADLINE]`

Секция помещается в качестве заголовка.

`[BODY]`

`Тело отчета`

`[END BODY]`

Эта секция в зависимости от режима печати (см. ниже) может повторятся n
количество раз или быть основным массивом данных отчета, только здесь возможна
подстановка данных из НД.

`[FUTER]`

`Содержит текст который добавится в конец отчета.`

`[END FUTER]`

`[CLOSE REP]`

`Содержит только команды уничтожения переменных.`

`[END CLOSE]`

**Команды :**

`DisposeVariable=`

Уничтожает одну переменную.

 

### Режимы печати

Существуют пять режимов печати отчетов, режим задается параметром *ViewMode*:

0 -- Производится печать отчета используя данные единственной записи, при этом
секция BODY повторится один раз.

1 -- Печатаются все записи НД, секция BODY повторится n раз, где n -- число
записей.

2 -- Будут печататься только те записи отчета которые помечены в таблице, для
этого в скрипте диалога должна стоять директива *MultiSelect=1*.

3 -- Будут печататься все записи НД и помещаться в разные файлы.

4 -- Будут печататься только те записи отчета, которые, помечены в таблице и
помещаться в разные файлы.

 

Порядок описания структуры отчета
---------------------------------

Для правильной интерпретации отчета необходимо описать его в соответствии с
некоторыми соглашениями.

Для извлечения данных из НД, следует описать их в виде директив вида:

:ИМЯ_ПОЛЯ[(длинна символов[выравнивание])]

Имя поля должно непременно иметь перед собой знак «:» двоеточие.

Где, выравнивание обозначается символами (L-(по умолчанию) выравнивание
относительно левого края, M-посередине, R-по правому краю, I --вставка
(производится вырезание строки с параметром на длину заполняемого значения)).
Число в скобках, определяет длину дополнения пробелами до заданной ширины или
обрезаемое в случае превышения длинны строки свыше указанного диапазона.
Объявленная директива будет заменена на значение из соответствующего поля с
именем директивы из набора данных, сформированного с помощью секции
*[GLOBALQUERY]*.

 

**Например :**

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:ACCOUNTNAME(30L)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
Команды для вызова отчета
-------------------------

`Report=`

Служит для печати отчета.

**Параметры :**

`ReportName=`

Определяет имя отчета для извлечения его из БД скриптов. Допускается

использовать переменные.

`FromFile=`

Если директива не пуста и присутствует то значение ReportName= игнорируется и

отчет берется из файла указанного в директиве.

`FromTable=`

Если не указанна директива *FromFile=*, тогда может быть использована

директива *FromTable=*, указывающая из какой таблицы будут браться отчеты, по
умолчания они берутся из системной таблицы. Таблица должна в точности повторять
структуру системной, вплоть до имен полей.

`QueryMode=`

Определяет, будет ли запрос из секции *[GLOBALQUERY]* отображаться или нет. По
умолчанию нет. Если да, то принимает значение *BkMode*. Если же требуется
выполнение только запроса из секции *[GLOBALQUERY]* то ставится значение
*Isolate*. Для использования запроса НД в отчёте он должен принять значение
*Main*;

`ViewMode=`

Режим печати отчета [(см. выше)](../HYPERLINK#Режимы_печати).

`Alias=` (BDE)

Устанавливает алиас для БД отчета.

`FileName=`

Имя файла отчета. Допускается использовать переменные. Из значения в директиве
удаляются следующие символы : /, ", \*, &, \>, \<.

 

**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SetValue=EP;ReturnQuery=select gb.param_value from params gb where gb.param_name='PathToReports';
Report=ReportName=ReportToClient2;QueryMode=Isolate;ViewMode=1;FileName=&EP/CallsStat_&CliName.txt;NoPrint=&PrintStat;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В примере после переменной содержащей путь к папке, стоит один из удаляемых
символов, он нужен для разделения имён переменных, а за ним имя файла.

`ToDos=`

Если равно *1*, то выдает отчет в кодировке DOS.

`NoPrint=`

Если равно *1*, то происходит просто сохранение в файл, без вывода на просмотр.
Допустимо подставлять значение из переменных.

`Viewer=`

Позволяет указать другую программу просмотра.

 

>   **Примечание :**

>   Имя отчета должно быть уникально.

 

Функции
=======

Для конвертации значений в DCL5, используются функции. Вызов функций
осуществляется через префикс «!!», за ним сразу идёт название функции и в
скобках значение. Допускаются вложение функций. После обработки функции остаётся
преобразованное значение.

 

Файловые функции
----------------

`DeleteNonFilesSimb(аргумент)` -- удаляет из переданного значения все символы не
используемые в именах файлов.

`GetFileNameToTranslite(ИмяФайла\С\Путём.txt)` -- Преобразовывает имя файла
русскими буквами в транслит, путь к файлу остаётся нетронутым.

`GetTempFileName(расширение)` -- Возвращает имя временного файла.

`MD5File(ИмяФайла)` -- Возвращает MD5 хэш файла.

 

Функции преобразования даты
---------------------------

Для конверсии дат в формат принятый в Oracle, где формат дат следующий,
«ГГГГ-ММ-ЧЧ 00:00:00» используются следующие функции.

`ConvertToOraDates(Дата)`\* --\* Используется для преобразования из формата даты
вида «ЧЧ.ММ.ГГГГ» в формат вида «ГГГГ-ММ-ЧЧ 00:00:00», в качестве параметра
принимающая переменную или просто значение даты. Для обратного преобразования
используется функция *ConvertOraDates*.

`ConvertToAccessDate(Дата)` -- Используется для преобразования из формата даты
вида «ЧЧ.ММ.ГГГГ» в формат вида «ММ.ЧЧ.ГГГГ», в качестве параметра принимающая
переменную или просто значение даты.

`DaysInAMonth(Номер месяца, Год)` -- Возвращает количество дней в указанном
месяце.

`MonthByDate(Номер месяца)` --- Возвращает название месяца в составе даты.

`DaysInMonth(Номер месяца)`\* ---\* Возвращает количество дней в месяце.

`GetMonthName(Номер месяцы)` -- Возвращает название месяца.

**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
select * from aaccmotionsfull t1 where t1.dateod between '!!ConvertToOraDates(&BEGDATE)' and '!!ConvertToOraDates(&ENDDATE)'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Функции форматирования
----------------------

`ToFloat(Число)` -- Преобразует целое число к формату с двумя знаками после
запятой.

 

**Пример :**

`ToFloat(42,4)` -- до преобразования.

42.40 после.

`ToFloat(42)` -- до преобразования.

42.00 после.

`MoneyToString(Число)` -- Выводит сумму прописью, копейки выводятся цифрами,
денежная единица рубли.

`LeadingZero(Число, Длина)` -- Возвращает *Число* дополненное до требуемой
*Длинны*, нулями вначале.

 

Функции работы с данными
------------------------

`IndexOf(Номер элемента во множестве счёт с 1, Строка значений, разделённых
запятыми)` -- Возвращает элемент во множестве значений, разделённых запятыми.
Допустимо указание нескольких множеств из переменных так и совместно,
непосредственно прописывая их как параметры.

`ByIndex(Образец для поиска, Множество или переменная содержащая множество)` --
Возвращает индекс элемента во множестве, счёт с 1. Допустимо указание нескольких
множеств из переменных так и совместно, непосредственно прописывая их как
параметры. Множества переданные из переменных или иным способом, должны быть
разделены запятыми.

>   **Примечание :**

>   В функциях *IndexOf и ByIndex* может быть произвольное количество
>   параметров, разделённых запятыми.

`NVL($ИМЯ_ПОЛЯ, Значение подстановки)` -- Производит подстановку значения во
втором параметре, если значение поля в первом параметре оказалось NULL. Имя поля
должно быть указано с предшествующим знаком \$.

`IIF(Условие, Значение если условие истинно, Значение если условие не
соблюдено)` -- Производит подстановку значений в зависимости от условия.

 

Строковые функции
-----------------

`MD5String(Произвольная строка)` -- Возвращает MD5 хэш строки.

`Upper(строка)` --- преобразует строку к верхнему регистру.

`Lower(СТРОКА)` --- преобразует строку к нижнему регистру.

 

Функции работы с настройками
----------------------------

В DCL5 есть возможность хранить настройки в таблице [глобальных
параметров](../HYPERLINK#Таблица_глобальных_параметров), для удобства обращения
с ней, существуют функции чтения и записи этих параметров. Параметры
представляют собой пары из имени и значения настройки, всегда строкового.

`ReadConfig(Имя_параметра[, ID_ПОЛЬЗОВАТЕЛЯ])` -- производит чтение значения из
ТГП и подстановку его вместо функции.

`WriteConfig(Имя_параметра, Значение_параметра[, ID_пользователя])` --
производит запись параметра, функция из текста вырезается.

Параметр *ID_ПОЛЬЗОВАТЕЛЯ,* является не обязательным, если он опущен, то
происходит чтение или запись параметра без учёта этого признака.

 

Функции преобразования
----------------------

`GetAccessLevelByName(НАЗВАНИЕ_УРОВНЯ_ПРАВ)` -- Преобразует псевдоним уровня
доступа к числовому значению, пригодному для употребления в выражениях
оперирующими с правами доступа.

>   **Примечание :**

>   Сначала произойдет трансляция переменных, а потом

>   трансляция функций.

>   Поддерживаются вложение функций.

 

Математические функции
----------------------

`Eval(Формула)` -- Вычисление формулы и возвращение результата. Использовать эту
функцию везде, не целесообразно, так как, вычисление формул и так происходит в
большинстве мест, таких как размеры компонентов, например.

 

Роли и права доступа
====================

Для разделения функций приложения между пользователями в DCL5 введены роли. Роли
-- это средство разграничения доступа и упорядочивания элементов меню между
пользователями. Для введения ролей в приложение нужно создать соответствующие
таблицы. Описание структуры таблиц в разделе [Структуры
таблиц](../HYPERLINK#Структура_таблиц).

Для использования расширенного режима назначения ролей, когда несколько ролей
могут быть назначены одному пользователю. Это позволяет, например, определить
несколько базовых интерфейсов и совмещать их для получения нужного результата.

 

**Пример :**

Например, имеется интерфейс «Базовый» и интерфейс «Операции», совместив их в
одном пользователе, получится полноценный интерфейс рабочего места Оператора.

Для указания пользователя, используется параметр *DCLUserName=*, указанное в
файле [настройки модуля](../HYPERLINK#Настройка_модуля).

Право доступа определено для каждого пользователя числом от 0 до 8 (см.
таблицу).

Права с *Уровень 1* по *Уровень 4*, являются дополнительными для права 3 и не
дают пользователю никакого преимущества над полными правами. Они предназначены
для расширения диапазона прав пользователей с полными правами, посредством
логики языка DCL5. Право *Разработчик*, так же не даёт дополнительных
возможностей, за исключением того, что позволяет запускать конфигуратор.

*Таблица с описанием прав:*

| Номер | Символьное  | Название      | Описание                                                                                                                                                 |
|-------|-------------|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0     | ulDeny      | Запрет входа  | При этом праве, при попытке входа, пользователю выдаётся сообщение, «Вам запрещён вход в систему».                                                       |
| 1     | ulReadOnly  | Только чтение | Позволяет только просматривать данные и запускать отчёты. Запуск приложений из системы запрещён.                                                         |
| 2     | ulWrite     | Правка        | Позволяет только редактировать таблицы, редактировать которые разрешено стандартными средствами. Выполнение SQL-запросов, под любым предлогом запрещено. |
| 3     | ulExecute   | Полные права  | Можно всё.                                                                                                                                               |
| 4     | ulLevel1    | Уровень 1     | То же что и право ulExecute.                                                                                                                             |
| 5     | ulLevel2    | Уровень 2     | То же что и право ulExecute.                                                                                                                             |
| 6     | ulLevel3    | Уровень 3     | То же что и право ulExecute.                                                                                                                             |
| 7     | ulLevel4    | Уровень 4     | То же что и право ulExecute.                                                                                                                             |
| 8     | ulDeveloper | Разработчик   | Позволяет запускать конфигуратор.                                                                                                                        |

Системная переменная встроенного языка *\_FULLRAIGHTS\_*, возвращает полный
уровень пользователя в соответствии с правами роли, чем выше право роли, тем
выше право пользователя с тем же уровнем прав, что у пользователя с правами роли
пониже. Права роли, хранятся в соответствующем поле таблицы ролей. Уровень прав
роли можно задать только в таблице ролей.

>   **Примечание :**

>   При запуске с зажатой клавишей *Shift*, происходит показ окна авторизации,
>   даже если имя пользователя и пароль предопределены в файле *DCL.ini*.

![](LogonDialog.png)

 

Что можно и нельзя разделить с помощью ролей?
---------------------------------------------

С помощью ролей явно можно разделить следующие вещи:

-   Элементы меню.

-   Формы (только ограничение).

-   Элементы интерфейса основной формы.

-   Параметры отчетов.

-   Команды инициализации и завершения.

-   Права на редактирование данных.

Так же возможно косвенное разделения запускаемых отчетов например с помощью
такой конструкции :

**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If Expression1=MASHA; Expression2=&ROLENAME; then
Report=ReportName=RepArc1;FileName=Reestr.txt;ViewMode=1
Else
Report=ReportName=Svodka;FileName=Total.txt;ViewMode=1
EndIf
If Expression1=SASHA; Expression2=&ROLENAME; then
Report=ReportName=Itog;FileName=Reestr.txt;ViewMode=1
EndIf
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Невозможно явно разделить запускаемые командные и визуальные скрипты, но их так
же можно разделять косвенно, например:

**Пример** :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Script type=command
If Expression1=ALEX; Expression2=&ROLENAME; then
Dialog=InputDocs_Alex;
EndIf
If Expression1=IRA; Expression2=&ROLENAME; then
Dialog=InputDocs_IRA;
EndIf
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

С помощью такой конструкции, возможно запускать тот или иной диалог. При этом в
поле команды ни чего не должно быть.

 

Ограничение операций набора данных
----------------------------------

Для ограничения некоторых операций с набором данных, без понижения прав
пользователя используется предложение :

`AddNotAllowOperation=`

в которое подставляются значения запрещающих действий, например:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AddNotAllowOperation=delete,insert;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Произведут запрещение операций удаления и вставки.

Не на всех типах платформ это предложение будет работать одинаково. На ADO
платформе, невозможно корректно запретить удаление.

 

Ограничение доступа к формам
----------------------------

Для ограничения доступа к формам на уровне прав доступа пользователя,
используется следующая директива:

`UserAccessRaight=` (V)

В ней указывается уровень прав пользователя на открытие этой формы. Открывать
форму смогут пользователи, у которых право равно или больше указанного значения.
Значение можно указывать как символьное, так и числовое из
[таблицы](#Таблица_прав) значений прав.

`SetUserAccessRaight=` (V)

Устанавливает уровень прав для текущей формы. Значение можно указывать как
символьное, так и числовое. Для пользователя с уровнем прав «*Уровень 4»* и
выше, эта директива не действует.

 

Запуск скриптов из файлов
=========================

Из специально подготовленных файлов возможно запускать скрипты. Правом создания
таких файлов обладает пользователь с правами **Разработчик**. Изначально файл
представляет собой обычный текстовый файл с расширением *.dst*. Потом, с помощью
интерактивной команды `SignScript`, осуществляется подписание скрипта и
последующее его сжатие, получается конечный файл с расширением *.dcs*. В
дальнейшем, исполнять этот скрипт могут все пользователи вошедшие в систему,
только не с правом **Только чтение**, с помощью интерактивной команды
`OpenScript`. При смене пароля пользователя, подписавшего скрипт, выполнение его
станет невозможным, тогда скрипт нужно будет переподписать с помощью команды
`ReSignScript`*.* Или извлечь обратно с помощью команды `ExtractScript`.

Все перечисленные команды могут быть как интерактивными так и не интерактивными,
принимая значения параметра `FileName=`, в качестве имени файла. Интерактивные
команды оканчиваются точкой с запятой, командные, содержат знак равно после
своего имени.

В файле может быть несколько скриптов, даже целая подсистема. Обязательно,
каждый скрипт должен быть заключён в секцию, которая начинается со строки
*[SCRIPTNAME=ИмяСкрипта]*, а заканчиваться строкой *[END SCRIPT]*. В файл, можно
поместить визуальные или командные скрипты, для визуальных скриптов, первой
строкой должна стоять строка *[FORM]*. По-умолчанию скрипт считается командным.

 

Оповещения
==========

Уведомления могут использоваться для оповещения пользователя или все
пользователей одновременно и(или) для завершения их работы.

Для назначения оповещений служит системная
[таблица](../HYPERLINK#Структура_таблиц), содержащая сами оповещения и их
атрибуты.

**Атрибуты оповещений :**

-   Время наступления оповещения;

-   Действие;

-   Статус;

-   Идентификатор пользователя в таблице ролей;

-   Текст оповещения/Запускаемая программа;

Значением поля «Действие» задаётся действие системы при оповещениях.

 
**Коды действий :**

0 -- Оповещение исполнено.

1 -- Запуск скрипта.

2 -- Просто оповещение. Показ его в форме оповещений.

3 -- Запуск приложения с ожиданием завершения.

4 -- Запуск приложения без ожидания.

5 -- Завершение работы через 30 сек. С выдачей сообщения.

Статусом оповещения является признак, того, доставлено или ещё не доставлено
оповещение, потому что его время ещё не наступило или пользователь не вошёл в
систему. При создании оповещение числовой код его статуса должен быть не равен
0.

Выполняются оповещения в порядке, приведённом в списке, сначала выполнятся
оповещения с наименьшим номером.

 

Запуск с формой в главном окне
==============================

Часто требуется запустить подсистему с уже открытой формой, для этого служит
параметр командной строки `Form=`, где после знака равно указывается имя скрипта
формы. При этом откроется заданная форма без основного меню программы, для
открытия формы с основным меню используется опция `MainMenu=1`.

 

Рекомендации по написанию скрипов
=================================

С начало, как правило, описываются все переменные и алиасы баз данных. Затем
описываются все запросы и фильтры.

Обязательно, что бы все таблицы имели поле с уникальным значением в каждой
записи, это нужно для однозначного определения записи с помощью SQL запроса.

Все команды должны быть написаны без отступа и не должны переносится на новую
строку. Знаком комментария являются две косые черты подряд //.

Во избежание ошибок все директивы предложений завершайте символом «;» точка с
запятой, иначе интерпретатор не сможет разделить параметры. Так же этим символом
оканчиваются команды без параметров, такие как Insert, Next, Last и т.д.

Именуйте скрипты начиная с названия подсистемы, потом названия диалога или
действия, затем типа скрипта (диалог, командный скрипт). Такое соглашение по
именованию позволит в дальнейшем, легко находить нужные скрипты.

 

Терминологический словарь
=========================

*Директива* -- какое либо ключевое слово в предложении, с присвоенным значением.
Присвоение осуществляется через знак «=» равно.

*Предложение* -- ключевое слово и следующий за ним набор из нескольких директив.
Предложением может так же являться и одна единственная директива, стоящая на
одной строке.

*БД* -- база данных.

*ТГП* -- таблица глобальных параметров, подробно описана в разделе [Структура
таблиц](../HYPERLINK#Таблица_глобальных_параметров).

*НД* -- набор данных. Результат выполнения запроса возвращающего данные. Не
стоит понимать под этим термином, таблицу.

*Платформа* -- Исполняемый модуль (программа), исполняющий скрипты на языке
DCL5.

*Диалог* -- форма (окно) на котором располагаются визуальные элементы
отображения данных.

*Отчёт* -- скрипт, содержащий шаблон для текстового вывода и команды его
построения.

*Скрипт* -- текст сценария для выполнения каких либо действий или для построения
диалога.

*Контекст* -- область действия запроса и визуальных компонентов, которыми можно
оперировать с помощью команд. Или, область действия команд оперирующих запросом
или компонентами на форме.

*Набор параметров* -- набор значений, какой либо директивы, разделенных
запятыми.

*Параметр запроса* -- имя поля просматриваемой таблицы, перед которым стоит
символ

« : », при выполнении запроса, параметр заменяется на соответствующее значение
этого поля.

*Переменная* -- заранее объявленное с помощью предложения *Declare=* слово с
префиксом «&» подставляемое в выражение или запрос.

*Секция* -- блок текста скрипта, начинающийся от конструкции следующего вида
*[Служебное слово]*. В DCL5 не существует явного конца секции, поэтому она может
продолжаться до следующего такого же объявления, например как секция *[Page]*,
или ее конец определяется предназначением секции, секция *[Fields]* .

*Курсор данных* -- объект, содержащий набор строк записей НД.

*Роль* -- способ разделения меню и настроек отчетов между пользователями.

 

Структура таблиц
================

Для работы модуля необходимо, что бы структура таблиц скриптов и ролей
соответствовала определенным требованиям:

-   у таблиц очень рекомендуется делать поле уникального идентификатора.

-   поле числового типа, должно помещать числовое значение в диапазоне от -1 до

-   строковое поле должно вмещать до 50 символов, но желательно до 1000.

-   поле с текстом скрипта, всегда должно иметь текстовый или тип Memo или любой
    другой тип вмещающий текст с символами переноса строк.

 

*Таблица скриптов:*

*Имя : DCL\_ SCRIPTS*

| Название поля | Тип                | Размерность | Назначение                               |
|---------------|--------------------|-------------|------------------------------------------|
| NUMSEQ        | Число, Уникальное  |             | может быть использовано для ролей        |
| DCLNAME       | Строка, Уникальное | 50          | поле имени скрипта                       |
| DCLTEXT       | Текст              |             | поле с текстом скрипта                   |
| COMMAND       | Строка             | 50          | поле, содержащее команды                 |
| IDENT         | Число              |             | идентификатор                            |
| PARENT        | Число              |             | , определяющее принадлежность к объектам |

*Таблица отчётов (если используется)***:**

*Имя : DCL_REPORTS*

| Название поля | Тип                | Размерность | Назначение                 |
|---------------|--------------------|-------------|----------------------------|
| Произвольное  | Число, Уникальное  |             | уникальный идентификатор   |
| DCLName       | Строка, Уникальное | 50          | имя со скриптом отчёта     |
| DCLText       | Текст              |             | текст шаблона отчёта       |
| USERID        | Число              |             | Идентификатор пользователя |

*Таблица пользователей:*

*Имя: DCL_USERS*

| Название поля        | Тип                | Размерность                                             | Назначение                                                                                                                                          |
|----------------------|--------------------|---------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| UID                  | Число, Уникальное  |                                                         | уникальный идентификатор                                                                                                                            |
| DCL_USER_NAME        | Строка, Уникальное | 30                                                      | имя пользователя                                                                                                                                    |
| DCL_LONG_USER \_NAME | Строка             | 50                                                      | полное имя пользователя                                                                                                                             |
| DCL_USER_PASS        | Строка             | 35                                                      | пароль                                                                                                                                              |
| DCL_ROLE             | Число              |                                                         | поле, содержащее идентификатор роли из таблицы ролей                                                                                                |
| SHOWINLIST           | Число              |                                                         | показывать в списке (если значение поля «1» то показывать                                                                                           |
| ACCESSLEVEL          | Число              | Значения: От 0 до 8. (см. таблицу уровней прав доступа) | Определяет права пользователя. Поле может отсутствовать, тогда значения прав пользователей будут максимальными.                                     |
| DBUSER_NAME          | Строка             | 300                                                     | поле используется для указания пользователя или строки соединения, при подключении пользователя, выполняется переподключение к БД с этим логином \* |
| DCL_USERS            | Строка             | 25                                                      | пароль для подключения к БД                                                                                                                         |

\* если ничего не указано, то переподключения не происходит.

*Таблица ролей:*

*Имя : DCL_ROLES*

| Название поля    | Тип                | Размерность | Назначение                    |
|------------------|--------------------|-------------|-------------------------------|
| ROLESID          | Число, Уникальное  |             | уникальный идентификатор роли |
| ROLENAME         | Строка, Уникальное | 30          | имя роли                      |
| LONGROLENAME     | Строка             | 50          | полное имя роли               |
| ROLE_ACCESSLEVEL | Число              |             | уровень прав роли             |

*Таблица меню ролей:*

*Имя : DCL_ROLESMENU*

| Название поля | Тип   | Размерность | Назначение                                   |
|---------------|-------|-------------|----------------------------------------------|
| ROLEID        | Число |             | поле для связи с таблицей ролей              |
| MENUITEMID    | Число |             | поле, содержащее идентификатор элемента меню |

*Таблица связи пользователей с ролями :*

*Имя : DCL_ROLES_TO_USERS*

| Название поля | Тип   | Размерность | Назначение                 |
|---------------|-------|-------------|----------------------------|
| RU_ROLEID     | Число |             | идентификатор роли         |
| RU_USERID     | Число |             | идентификатор пользователя |

*Таблица хранилища шаблонов/двоичных данных:*

*Имя по умолчанию : DCL_TEMPLATES*

| Название поля | Тип                       | Размерность | Назначение              |
|---------------|---------------------------|-------------|-------------------------|
| TEMPL_NAME    | Строка                    | 50          | имя шаблона             |
| TEMPL_DATA    | Хранилище двоичных данных |             | двоичные данные шаблона |

*Таблица глобальных параметров:*

*Имя : DCL_GLOBAL_PARAMS*

| Название поля  | Тип    | Размерность | Назначение                                                                                     |
|----------------|--------|-------------|------------------------------------------------------------------------------------------------|
| PARAM_NAME     | Строка | 50          | имя параметра                                                                                  |
| PARAM_VALUE    | Строка | 150         | значение параметра                                                                             |
| PARAM_USERID   | Число  |             | идентификатор пользователя (не обязателен)                                                     |
| PROGRAMM_PARAM | Число  |             | вспомогательное поле, содержит 1 если параметр относится к пользовательской части конфигурации |

*Таблица оповещений:*

*Имя : DCL_NOTIFYCATIONS*

| Название поля | Тип        | Размерность | Назначение                                         |
|---------------|------------|-------------|----------------------------------------------------|
| NOTIFY_TIME   | Дата/Время |             | время наступления оповещения                       |
| NOTIFY_ACTION | Число      |             | действие                                           |
| NOTIFY_STATE  | Число      |             | статус                                             |
| USER_ID       | Число      |             | идентификатор пользователя в таблице пользователей |
| NOTIFY_TEXT   | Строка     | 250         | текст оповещения                                   |

*Таблица параметров диалогов:*

*Имя : DCL_INI_PROFILES*

| Название поля   | Тип                       | Размерность | Назначение                                                   |
|-----------------|---------------------------|-------------|--------------------------------------------------------------|
| INI_USER_ID     | Число                     |             | числовой идентификатор пользователя из таблицы пользователей |
| INI_DIALOG_NAME | Строка                    | 150         | имя диалога                                                  |
| INI_PARAM_VALUE | Хранилище двоичных данных |             | значение параметра настройки                                 |

 

Контроль версии модуля
======================

Так как версия языка может измениться, могут появиться какие то особенности,
которые ещё не поддерживаются старой версией модуля, существует контроль версий.
Для этого в таблице скриптов, должна быть запись с полем указанным в параметре
*DCLNameField* версии модуля, совместимая с используемым языком. Версия должна
быть в виде групп цифр по две в группе и состоять из четырёх групп. Если в
группе одна цифра, она должна быть дополнена ведущим нулём. Например,
*06.07.11.40*. В поле, указанным в параметре *IdentifyField,* должен содержаться
идентификатор равный *50000*.

 

Информация о конфигурации
=========================

В таблице скриптов в элементе с кодом 60000 хранится текстовая о конфигурации,
она заноситься в поле текста скрипта. В элементе с кодом идентификатора равным
60001 в поле имени скрипта, храниться версия или иное представление о версии
конфигурации.

 

Коды ошибок
===========

В DCL5 существует две категории кодов ошибок:

•Ошибки модуля:

Имеют следующий формат 0XXX и указываются без знака «-» в начале и начинаются с
0.

•Ошибки языка.

Имеют ведущий знак «-» и не начинаются с 0.

 
### Системные :

•Не удалось подсоединиться к БД. 0000

•Файл конфигурации не найден. 0010

•Строка соединения неверна. 0100

•Нет меню. 0200

•Таблица ролей не найдена. 0300

 
### Ошибки языка :

Закончилась память под переменные. -2001

Создано слишком много переменных.

Ошибка в выражении. -1108

Ошибка в SQL запросе в предложении GrabValueFromBase, формы ввода значений в
отчётах.

Ошибка в выражении. -1106

Ошибка в синтаксисе запроса отчёта.

Ошибочный запрос в параметре: ParamName -1109.

Ошибка интерпретации запроса в параметре отчёта.

Ошибка в выражении. -1102

Ошибка в SQL запросе предложения If ... then.

Невозможно создать форму, закончились позиции. -3018

Ошибка в процедуре NextForm при получении следующей формы.

Ошибка в выражении. -1105

Ошибка в запросе предложения SetValue=.

Ошибка в выражении. -1110

Ошибочный запрос в предложении ModifyingQuery=.

Ошибочный запрос или не верные условия поиска. -1111

Ошибка введённых не корректно условий поиска или ошибки в SQL запросе секции
XxxxQuery=.

Ошибочный запрос. -1112

Ошибка в предложении Query= командного скрипта.

Ошибочный запрос. -1200

Ошибочный запрос в предложении TablePart=.

Ошибочный запрос. -1201

Ошибочный запрос в предложении TablePart= командного скрипта.

Ошибочный запрос. -1113

Ошибка в предложении GlobQuery= командного скрипта.

Файл не найден. -8000

Ошибка запуска, выдаётся командой Execute=.

Файл не найден. -8001

Ошибка команды PutInDB=, файл для загрузки не найден.

Ошибка преобразования. -7000

Некорректно указан номер табличной части в предложении CurrentTablePart=.

Ошибка в выражении прав доступа. -9000

Ошибка в выражении подзапроса прав доступа.

Ошибочный запрос. -1114

Ошибочный запрос в предложении SetMainQuery=.

Ошибка OLE. -6000

Ошибка создания OLE объекта Excel.

Нет области данных "DATA". -5001

Возникает при отсутствии ячейки с именем DATA при выводе данных в Excel отчёт.

Ошибка в выражении. -1104

Ошибка в SQL выражении Excel отчёта.

Нет файла шаблона. -5002

Нет файла шаблона Excel отчёта.

Ошибочный запрос. -1100

Ошибка в запросе предложения Query= диалога.

Ошибочный запрос. -1101

Ошибка при выполнении запроса командой Open.

Ошибочный запрос. -1115

Ошибка выполнения запроса в предложении QueryLookup= или Lookup=.

Ошибочный запрос в DBFilter=. -1116

Ошибочный запрос в предложении DBFilterQuery= или DBFilter=.

Ошибка в выражении. -1117.

Ошибка в SQL запросе получения ключевого значения в предложении DBFilterQuery=
или DBFilter= параметра KeyValue=.

Ошибочный запрос. --1118

Ошибочный запрос в предложении SummQuery=.

Недостаточно или много параметров в предложении. -4000

Не правильно указаны параметры объединения фильтров в диапазон фильтрации.

Недостаточно или много параметров в предложении. -4001

Не правильно указаны параметры объединения контекстных фильтров в диапазон
фильтрации.

Ошибочный запрос. -1200

Ошибочный запрос в предложении TablePart= директивы SQL= табличной части.

Ошибочный запрос. -1103

Ошибочный запрос в предложении LoadFromTable=.

Неверный формат полей. -4002

Нет количества полей или описания полей в секции [Fileds].

Ошибка в выражении. -1107

Ошибка в SQL выражении PickList=.

 

Параметры командной строки
==========================

С помощью параметров командной строки можно запускать платформу с желаемыми
параметрами.

**Параметры:**

`-ini ИмяФайла.ini`

Альтернативный файл конфигурации.

`-user ИмяПользователя`

Перекрывает имя пользователя в ini файле, но не в таблице параметров.

`-password Пароль`

Перекрывает пароль в ini файле, но не в таблице параметров.

`-scr ИмяФайлаСкрипта.dcs`

Запустить подписанный скрипт из файла.

`-dialog ИмяСкриптаДиалога`

Открыть диалог сразу после запуска приложения.

 

Настройка модуля
================

Для обеспечения работы модуля, ему необходимо передать некоторые параметры,
такие как: алиас базы скриптов, имя таблицы, список полей и т.д.. Для этого
имеется файл *DCL.ini* в нем указываются все эти параметры. Если же требуется
указать другой файл конфигурации, не тот, что находится в каталоге программы и
имеет имя *DCL.ini*, а другой, то его имя передается через командную строку
первым параметром или через параметр -ini. Файл должен иметь следующее
содержание:

 
Параметры соединения :
----------------------

*UserName=*(IB, BDE, ZEOS)

Используется для передачи имени пользователя для подключения к БД.

*Password=* (IB, BDE, ZEOS)

Передает в БД пароль для открытия.

*Alias=*(BDE)

Определяет алиас таблицы со скриптами.

*ConnectionString=*(ADO)

Строка соединения в формате ADO.DB. Строка соединения может быть создана с
помощью среды разработки *Friday* или с помощью утилиты
*ConnectionStringBuilder* входящей в комплект поставки.

Вместо строки соединения можно использовать UDL файл. Указать его имя с помощью
директивы «FILE NAME=Имя\\Файла\\Соединения.udl»

**Пример** :

`FILE NAME=C:\DCL\Data Links\DBDEMOS.udl`

Создать файл можно так:

Создайте файл с расширением .udl, щёлкните по нему дважды, и появится редактор
подключений, в нём нужно задать параметры подключения и нажать OK.

*DriverName=*(BDE)

Определяет имя драйвера БД.

*ServerName=* (IB, BDE, ZEOS)

Используется для сервера IntrBase/FireBird, для задания пути файла базы данных
на сервере.

*DefaultDriver=*(BDE)

Используется для локальных таблиц, указания драйвера таблицы.

*DBPath=*(IB, BDE, ZEOS)

Определяет путь к локальным таблицам. Если используется этот параметр, то
значение *UserName=* не должно быть пустым.

DBTypeIB=(IB)

Принимает значение «1» - Да. Указывает на то, что подключение происходит к
серверу InterBase, FireBird, Yaffi и их клонам.

*CodePage=*(IB, ZEOS)

В параметре задаётся кодовая страница для подключения к БД, если параметр не
задан, то берётся текущая кодировка системы.

StringTypeChar=

Определяет символ, использующейся в качестве символа ограничивающего значения
полей строк и дат. Может принимать значения: " или '. Если ни чего не указанно,
то по умолчанию будет (").

*SQLDialect=*(IB)

Определяет SQL диалект базы данных. Используется с сервером Firebird.

*LibPath=*(ZEOS)

Путь к библиотеке соединения сервером БД. Параметр читается если используется
версия приложения с механизмом доступа ZEOS.

*LibPath_x64=*(ZEOS, x64)

Путь к библиотеке соединения сервером БД. Параметр читается только если
используется 64х битная версия приложения с механизмом доступа ZEOS.

 
Параметры структуры таблиц :
----------------------------

### Параметры для DCLDeveloper :

*Эти параметры не доступны для клиентской части DCL.*

*DCLTable=*

Указывает имя таблицы содержащей тексты скриптов.

*DCLNameField=*

Определяет поле с именами скриптов или заголовками меню и главной формы.

*DCLTextField=*

Определяет поле с текстом макроса.

*IdentifyField=*

Указывается поле идентификатора, используется для меню.

*ParentFlgField=*

Поле указывающее родительский объект. Используется для построения меню.

*CommandField=*

Поле, содержащее команды, используется для меню.

*NumSeqField=*

Поле, идентификатор элемента таблицы скриптов.

*RoleName=*

Имя роли для входа (не в таблице).

*LongRoleNameField=*

Поле содержащее полное имя роли в таблице ролей.

*RolesTable=*

Таблица с ролями. Если не указанно, то равно Roles.

*RoleIDFiled=*

Поле идентификатора роли. Если не указанно, то равно RoleID.

*RoleNameField=*

Поле имени роли. Если не указанно, то равно RoleName.

*ShowRoleField=*

Поле, содержащее значение определяющее, показывать ли в списке выбора эту роль.

*RolesMenuTable=*

Таблица элементов меню роли. Если не указанно, то равно RolesMenu.

*RoleMenuIDField=*

Поле идентификатора роли в таблице элементов меню роли. Если не указанно, то
равно `RoleID`.

*MenuItemID=*

Поле, содержащее идентификатор элемента меню. Если не указанно, то равно `MenuItemID`.

*RolPassField=*

Поле с паролем роли в таблице ролей.

*TemplatesTable=*

Таблица данных шаблонов.

*TemplatesNameField=*

Имя поля, хранящее имя шаблона в таблице шаблонов.

*TemplatesDataField=*

Поле двоичных данных шаблона.

*GeneratorName=*

Определяет имя последовательности в базах данных Firebird/Interbase привязанного
к таблице скриптов.

 

### Настройка модуля :

*DCLUserName=*

Имя пользователя для входа (не в таблице).

*DCLUserPass=*

Пароль для пользователя (не в таблице) (не обязателен), если не указан то будет
запрашиваться.

*MultiRoles=*

Если значение установить в «1», то будет использоваться расширенная система
ролей. Когда одному пользователю может быть назначено несколько ролей,
результатом такого объединения станет объединения множеств ролей.

*UserLogging=*

Вести таблицу активных пользователей. Параметр может быть только включён,
значение «1».

*UserLoggingHistory=*

Вести журнал входов пользователей в программу. Параметр может быть только
включён, значение «1».

*UpperBase=*

Использовать во внутренних запросах к базе выражение Upper. Принимает значения 1
-- применять (по умолчанию) или 0 -- не использовать. Может быть использовано
при работе совместно с Access.

*HashPassword=*

Позволяет хранить хешированные пароли в MD5. По умолчанию отключена.

*ShowPicture=*

Определяет показывать или не показывать изображения в таблице, если да то
принимает значение *1*, по умолчанию нет, не показывать, *0*.

*ShowFormPanel=*

Разрешает показывать кнопки форм на панели форм.

*DialogsSettings=*

Если равно *1* (по умолчанию), то происходит автоматическое сохранение положение
окон и полей.

*FormPosInDB=*

Хранение настроек диалогов в базе. Указывается вариант сохранения настроек, при
значении равном «0», сохранения настроек в БД не происходит, они сохраняются как
обычно, в ini файле. При значении равном «1», настройки сохраняются в БД, при
значении равном «2», происходит сохранение настроек и в БД и в ini файле, но
чтение из ini файла. Такой режим может использоваться для перехода от сохранения
в файле к сохранению в БД, без потери всех настроек.

*DisableFieldsList=*

Запрещает использовать режим автоматического сохранения положения и набора
полей, если значение равно *1*. Не работает, если параметр *DialogsSettings=*
установлен в *0*.

*DisableColors=*

Запрещает применение цветов, предложения *Color*.

*MainFormCaption=*

Текст, добавляемый к заголовку основной формы.

*ConfirmExit=*

Подтверждение выхода из приложения.

*UserLocalProfile=*

Путь к папке локального профиля пользователя для хранения файлов программы, если
значение не задано, то используется следующий путь: *%AppData%\\DCL5\\* для
Windows и *\~/.config/DCL5/* для Linux. При задании пути, символ разделителя
папок, должен быть в конце. В качестве значений можно использовать системные
переменные, например \_APPPATH_, которая вернёт путь к папке с программой,
однако такой путь не рекомендуется и применим только для совместимости со
старыми версиями или для приложений не могущими работать с национальными
символами в пути.

*Debug=*

Позволяет выводить отладочную информацию в файл. Если равно *1*. Отладку так же
можно включить, если запустить приложение с ключом */debug*.

*DebugMesseges=*

Вывод отладочной информации во время выполнения программы.

*UseMessages=*

Использовать сообщения пользователям. По умолчанию включено.

*OneCopy=*

При значении равном 1, не позволяет запустить вторую копию приложения с одним и
тем же методом доступа к данным.

*Viewer=*

Указывает программу просмотра.

*GetValueSeparator=*

Устанавливает разделитель при выборе нескольких значений через диалоги выбора.
По умолчанию равно «,».

*OldStyle=*

Делает окна в стиле Windows 3.11.

*OfficeType=*

Тип офисного пакета по умолчанию. Принимает значения: «MSO»-Microsoft Office, «OO»-Open Office.

*OfficeDocumentFormat=*

Формат шаблонов и сохраняемых документов офисных пакетов, может принимать
значения «MSO»-Microsoft Office, «OO»-Open Office. По умолчанию равно MSO.

 

### Настройки формата даты и времени

*DateFormat=*(Linux)

Если требуется задать какой-то специфичный формат даты, его можно прописать в
этом параметре. По умолчанию представление даты имеет вид «ДД.ММ.ГГГГ».

*DateSeparator=*(Linux)

Разделитель формата даты, по умолчанию «.».

*TimeFormat=*(Linux)

Всё что было сказано о формате даты выше, относиться и к формату времени, с той
лишь разницей, что представление времени по умолчанию имеет вид «ЧЧ.ММ.СС».

*TimeSeparator=*(Linux)

Разделитель формата времени, по умолчанию «:».

 

Использование таблицы параметров
--------------------------------

Для задания параметров может так же использоваться таблица параметров, её
область действия распространяется на всех подключающихся пользователей, однако,
настройки в локальном файле DCL.ini перекрывают её настройки.

Для её использования достаточно создать таблицу (её имя
[DCL](../HYPERLINK#Структура_таблиц)[\_](../HYPERLINK#Структура_таблиц)[GLOBAL_PARAMS](../HYPERLINK#Структура_таблиц))
с полями значения и имени параметров и заполнить её значениями, будут восприняты
все значения, кроме параметров соединения с БД. Кроме того, становиться
возможным использование её для хранения значений, других глобальных параметров,
не относящихся к работе платформы. Для этого существуют
[функции](../HYPERLINK#Функции_работы_настройками) записи и чтения значений из
ТГП.

 

Файл Interface.ini
==================

Переключение интерфейса
-----------------------

Для выбора типа интерфейса MDI или SDI используется файл interface.ini
содержащий строку с названием интерфейса. Включение MDI интерфейса, можно
добиться, если запустить приложение с параметром *MDI=1*.